{
  "version": 3,
  "sources": ["../../lodash/noop.js", "../../lodash/_createSet.js", "../../lodash/_baseUniq.js", "../../lodash/uniq.js", "../../lodash/_baseIsMatch.js", "../../lodash/_isStrictComparable.js", "../../lodash/_getMatchData.js", "../../lodash/_matchesStrictComparable.js", "../../lodash/_baseMatches.js", "../../lodash/_baseMatchesProperty.js", "../../lodash/_baseProperty.js", "../../lodash/_basePropertyDeep.js", "../../lodash/property.js", "../../lodash/_baseIteratee.js", "../../lodash/uniqBy.js", "../../lodash/_baseForOwn.js", "../../lodash/_createBaseEach.js", "../../lodash/_baseEach.js", "../../lodash/_baseMap.js", "../../lodash/_baseSortBy.js", "../../lodash/_compareAscending.js", "../../lodash/_compareMultiple.js", "../../lodash/_baseOrderBy.js", "../../lodash/sortBy.js", "../../lodash/_baseIsDate.js", "../../lodash/isDate.js", "../../lodash/_baseFilter.js", "../../lodash/filter.js", "../../lodash/isNumber.js", "../../lodash/_arrayEach.js", "../../lodash/_baseAssign.js", "../../lodash/_baseAssignIn.js", "../../lodash/_copySymbols.js", "../../lodash/_getSymbolsIn.js", "../../lodash/_copySymbolsIn.js", "../../lodash/_getAllKeysIn.js", "../../lodash/_initCloneArray.js", "../../lodash/_cloneDataView.js", "../../lodash/_cloneRegExp.js", "../../lodash/_cloneSymbol.js", "../../lodash/_initCloneByTag.js", "../../lodash/_baseIsMap.js", "../../lodash/isMap.js", "../../lodash/_baseIsSet.js", "../../lodash/isSet.js", "../../lodash/_baseClone.js", "../../lodash/_baseSlice.js", "../../lodash/_parent.js", "../../lodash/_baseUnset.js", "../../lodash/_customOmitClone.js", "../../lodash/omit.js", "../../@nivo/scales/src/timeHelpers.ts", "../../@nivo/scales/src/linearScale.ts", "../../@nivo/scales/src/pointScale.ts", "../../@nivo/scales/src/bandScale.ts", "../../@nivo/scales/src/timeScale.ts", "../../@nivo/scales/src/logScale.ts", "../../@nivo/scales/src/symlogScale.ts", "../../@nivo/scales/src/compute.ts", "../../@nivo/scales/src/ticks.ts", "../../@nivo/scales/src/types.ts", "../../@nivo/axes/src/compute.ts", "../../@nivo/axes/src/components/AxisTick.tsx", "../../@nivo/axes/src/defaults.ts", "../../@nivo/axes/src/components/Axis.tsx", "../../@nivo/axes/src/props.ts", "../../@nivo/axes/src/components/Axes.tsx", "../../@nivo/axes/src/components/GridLine.tsx", "../../@nivo/axes/src/components/GridLines.tsx", "../../@nivo/axes/src/components/Grid.tsx", "../../@nivo/axes/src/canvas.ts", "../../@nivo/annotations/src/props.ts", "../../@nivo/annotations/src/utils.ts", "../../@nivo/annotations/src/compute.ts", "../../@nivo/annotations/src/hooks.ts", "../../@nivo/annotations/src/AnnotationNote.tsx", "../../@nivo/annotations/src/AnnotationLink.tsx", "../../@nivo/annotations/src/CircleAnnotationOutline.tsx", "../../@nivo/annotations/src/DotAnnotationOutline.tsx", "../../@nivo/annotations/src/RectAnnotationOutline.tsx", "../../@nivo/annotations/src/Annotation.tsx", "../../@nivo/annotations/src/canvas.ts", "../../@nivo/canvas/src/roundedRect.ts", "../../@nivo/bar/src/BarAnnotations.tsx", "../../@nivo/bar/src/BarLegends.tsx", "../../@nivo/bar/src/BarItem.tsx", "../../@nivo/bar/src/BarTooltip.tsx", "../../@nivo/bar/src/defaults.ts", "../../@nivo/bar/src/renderBar.ts", "../../@nivo/bar/src/compute/common.ts", "../../@nivo/bar/src/compute/grouped.ts", "../../@nivo/bar/src/compute/stacked.ts", "../../@nivo/bar/src/compute/legends.ts", "../../@nivo/bar/src/compute/totals.ts", "../../@nivo/bar/src/hooks.ts", "../../@nivo/bar/src/BarTotals.tsx", "../../@nivo/bar/src/Bar.tsx", "../../@nivo/bar/src/BarCanvas.tsx", "../../@nivo/bar/src/ResponsiveBar.tsx", "../../@nivo/bar/src/ResponsiveBarCanvas.tsx"],
  "sourcesContent": ["/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n", "var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n", "var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n", "var baseUniq = require('./_baseUniq');\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nmodule.exports = uniq;\n", "var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n", "var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n", "var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n", "/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n", "var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n", "var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n", "/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n", "var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n", "var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n", "var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n", "var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n", "var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n", "var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n", "var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n", "var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n", "/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n", "var isSymbol = require('./isSymbol');\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n", "var compareAscending = require('./_compareAscending');\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n", "var arrayMap = require('./_arrayMap'),\n    baseGet = require('./_baseGet'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    baseSortBy = require('./_baseSortBy'),\n    baseUnary = require('./_baseUnary'),\n    compareMultiple = require('./_compareMultiple'),\n    identity = require('./identity'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  if (iteratees.length) {\n    iteratees = arrayMap(iteratees, function(iteratee) {\n      if (isArray(iteratee)) {\n        return function(value) {\n          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n        }\n      }\n      return iteratee;\n    });\n  } else {\n    iteratees = [identity];\n  }\n\n  var index = -1;\n  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n", "var baseFlatten = require('./_baseFlatten'),\n    baseOrderBy = require('./_baseOrderBy'),\n    baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 30 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar dateTag = '[object Date]';\n\n/**\n * The base implementation of `_.isDate` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n */\nfunction baseIsDate(value) {\n  return isObjectLike(value) && baseGetTag(value) == dateTag;\n}\n\nmodule.exports = baseIsDate;\n", "var baseIsDate = require('./_baseIsDate'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsDate = nodeUtil && nodeUtil.isDate;\n\n/**\n * Checks if `value` is classified as a `Date` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n * @example\n *\n * _.isDate(new Date);\n * // => true\n *\n * _.isDate('Mon April 23 2012');\n * // => false\n */\nvar isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\nmodule.exports = isDate;\n", "var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n", "var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n *\n * // Combining several predicates using `_.overEvery` or `_.overSome`.\n * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n * // => objects for ['fred', 'barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar numberTag = '[object Number]';\n\n/**\n * Checks if `value` is classified as a `Number` primitive or object.\n *\n * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n * classified as numbers, use the `_.isFinite` method.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n * @example\n *\n * _.isNumber(3);\n * // => true\n *\n * _.isNumber(Number.MIN_VALUE);\n * // => true\n *\n * _.isNumber(Infinity);\n * // => true\n *\n * _.isNumber('3');\n * // => false\n */\nfunction isNumber(value) {\n  return typeof value == 'number' ||\n    (isObjectLike(value) && baseGetTag(value) == numberTag);\n}\n\nmodule.exports = isNumber;\n", "/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n", "var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n", "var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n", "var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n", "var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n", "var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n", "var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n", "var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n", "/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n", "var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n", "var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n", "var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n", "var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n", "var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n", "var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n", "var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isMap = require('./isMap'),\n    isObject = require('./isObject'),\n    isSet = require('./isSet'),\n    keys = require('./keys'),\n    keysIn = require('./keysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n", "/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nmodule.exports = baseSlice;\n", "var baseGet = require('./_baseGet'),\n    baseSlice = require('./_baseSlice');\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n}\n\nmodule.exports = parent;\n", "var castPath = require('./_castPath'),\n    last = require('./last'),\n    parent = require('./_parent'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = castPath(path, object);\n  object = parent(object, path);\n  return object == null || delete object[toKey(last(path))];\n}\n\nmodule.exports = baseUnset;\n", "var isPlainObject = require('./isPlainObject');\n\n/**\n * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n * objects.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {string} key The key of the property to inspect.\n * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n */\nfunction customOmitClone(value) {\n  return isPlainObject(value) ? undefined : value;\n}\n\nmodule.exports = customOmitClone;\n", "var arrayMap = require('./_arrayMap'),\n    baseClone = require('./_baseClone'),\n    baseUnset = require('./_baseUnset'),\n    castPath = require('./_castPath'),\n    copyObject = require('./_copyObject'),\n    customOmitClone = require('./_customOmitClone'),\n    flatRest = require('./_flatRest'),\n    getAllKeysIn = require('./_getAllKeysIn');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * The opposite of `_.pick`; this method creates an object composed of the\n * own and inherited enumerable property paths of `object` that are not omitted.\n *\n * **Note:** This method is considerably slower than `_.pick`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to omit.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.omit(object, ['a', 'c']);\n * // => { 'b': '2' }\n */\nvar omit = flatRest(function(object, paths) {\n  var result = {};\n  if (object == null) {\n    return result;\n  }\n  var isDeep = false;\n  paths = arrayMap(paths, function(path) {\n    path = castPath(path, object);\n    isDeep || (isDeep = path.length > 1);\n    return path;\n  });\n  copyObject(object, getAllKeysIn(object), result);\n  if (isDeep) {\n    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n  }\n  var length = paths.length;\n  while (length--) {\n    baseUnset(result, paths[length]);\n  }\n  return result;\n});\n\nmodule.exports = omit;\n", "import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n", "import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { interpolateRound, interpolateNumber } from 'd3-interpolate'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const linearScaleDefaults: Required<ScaleLinearSpec> = {\n    type: 'linear',\n    min: 0,\n    max: 'auto',\n    stacked: false,\n    reverse: false,\n    clamp: false,\n    nice: true,\n    round: false,\n}\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = linearScaleDefaults.min,\n        max = linearScaleDefaults.max,\n        stacked = linearScaleDefaults.stacked,\n        reverse = linearScaleDefaults.reverse,\n        clamp = linearScaleDefaults.clamp,\n        nice = linearScaleDefaults.nice,\n        round = linearScaleDefaults.round,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? (data.minStacked ?? 0) : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? (data.maxStacked ?? 0) : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .interpolate(round ? interpolateRound : interpolateNumber)\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n", "import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n", "import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const bandScaleDefaults: Required<ScaleBandSpec> = {\n    type: 'band',\n    round: false,\n}\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = bandScaleDefaults.round }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n", "import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const timeScaleDefaults: Required<ScaleTimeSpec> = {\n    type: 'time',\n    format: 'native',\n    precision: 'millisecond',\n    min: 'auto',\n    max: 'auto',\n    useUTC: true,\n    nice: false,\n}\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = timeScaleDefaults.format,\n        precision = timeScaleDefaults.precision,\n        min = timeScaleDefaults.min,\n        max = timeScaleDefaults.max,\n        useUTC = timeScaleDefaults.useUTC,\n        nice = timeScaleDefaults.nice,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n", "import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const logScaleDefaults: Required<ScaleLogSpec> = {\n    type: 'log',\n    base: 10,\n    min: 'auto',\n    max: 'auto',\n    round: false,\n    reverse: false,\n    nice: true,\n}\n\nexport const createLogScale = (\n    {\n        base = logScaleDefaults.base,\n        min = logScaleDefaults.min,\n        max = logScaleDefaults.max,\n        round = logScaleDefaults.round,\n        reverse = logScaleDefaults.reverse,\n        nice = logScaleDefaults.nice,\n    }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>().base(base)\n\n    const range = axis === 'x' ? [0, size] : [size, 0]\n    if (round === true) scale.rangeRound(range)\n    else scale.range(range)\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    // @ts-expect-error not sure why this is not working, it's available for symlog.\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n", "import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const symlogScaleDefaults: Required<ScaleSymlogSpec> = {\n    type: 'symlog',\n    constant: 1,\n    min: 'auto',\n    max: 'auto',\n    round: false,\n    reverse: false,\n    nice: true,\n}\n\nexport const createSymlogScale = (\n    {\n        constant = symlogScaleDefaults.constant,\n        min = symlogScaleDefaults.min,\n        max = symlogScaleDefaults.max,\n        round = symlogScaleDefaults.round,\n        reverse = symlogScaleDefaults.reverse,\n        nice = symlogScaleDefaults.nice,\n    }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>().constant(constant)\n\n    const range = axis === 'x' ? [0, size] : [size, 0]\n    if (round === true) scale.rangeRound(range)\n    else scale.range(range)\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n", "import uniq from 'lodash/uniq.js'\nimport uniqBy from 'lodash/uniqBy.js'\nimport sortBy from 'lodash/sortBy.js'\nimport last from 'lodash/last.js'\nimport isDate from 'lodash/isDate.js'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date | null\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date | null\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: readonly D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Exclude<Input, null>>(spec, data, size)\n        case 'band':\n            return createBandScale<Exclude<Input, null>>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n", "import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\n/**\n * Band and point scales are not centered, meaning the ticks would\n * be positioned at the beginning of each step; however, we want\n * them to be centered for each step.\n */\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable,\n            // however, local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n", "import {\n    ScaleLinear as D3ScaleLinear,\n    ScalePoint as D3ScalePoint,\n    ScaleBand as D3ScaleBand,\n    ScaleLogarithmic as D3ScaleLogarithmic,\n    ScaleSymLog as D3ScaleSymLog,\n    ScaleTime as D3ScaleTime,\n} from 'd3-scale'\nimport { TIME_PRECISION } from './timeHelpers'\n\nexport type ScaleAxis = 'x' | 'y'\nexport type OtherScaleAxis<Axis extends ScaleAxis> = Axis extends 'x' ? 'y' : 'x'\n\nexport type NumericValue = { valueOf(): number }\nexport type StringValue = { toString(): string }\nexport type ScaleValue = NumericValue | StringValue | Date | null\n\nexport interface ScaleTypeToSpec {\n    linear: ScaleLinearSpec\n    log: ScaleLogSpec\n    symlog: ScaleSymlogSpec\n    point: ScalePointSpec\n    band: ScaleBandSpec\n    time: ScaleTimeSpec\n}\n\nexport type ScaleType = keyof ScaleTypeToSpec\nexport type ScaleSpec = ScaleTypeToSpec[keyof ScaleTypeToSpec]\n\nexport type ReversibleScaleSpec = ScaleLinearSpec | ScaleLogSpec | ScaleSymlogSpec\n\nexport const isReversibleScaleSpec = (scaleSpec: ScaleSpec): scaleSpec is ReversibleScaleSpec => {\n    return scaleSpec.type === 'linear' || scaleSpec.type === 'log' || scaleSpec.type === 'symlog'\n}\n\nexport interface ScaleTypeToScale<Input, Output> {\n    linear: Input extends NumericValue ? ScaleLinear<Output> : never\n    log: Input extends NumericValue ? ScaleLog : never\n    symlog: Input extends NumericValue ? ScaleSymlog : never\n    point: Input extends StringValue ? ScalePoint<Input> : never\n    band: Input extends StringValue ? ScaleBand<Input> : never\n    time: Input extends StringValue | Date ? ScaleTime<Input> : never\n}\n\nexport type Scale<Input, Output> = ScaleTypeToScale<Input, Output>[keyof ScaleTypeToScale<\n    Input,\n    Output\n>]\n\nexport type ScaleLinearSpec = {\n    type: 'linear'\n    min?: 'auto' | number\n    max?: 'auto' | number\n    stacked?: boolean\n    reverse?: boolean\n    clamp?: boolean\n    nice?: boolean | number\n    round?: boolean\n}\nexport interface ScaleLinear<Output> extends D3ScaleLinear<number, Output, never> {\n    type: 'linear'\n    stacked: boolean\n}\n\nexport interface ScaleLogSpec {\n    type: 'log'\n    base?: number\n    min?: 'auto' | number\n    max?: 'auto' | number\n    round?: boolean\n    reverse?: boolean\n    nice?: boolean | number\n}\nexport interface ScaleLog extends D3ScaleLogarithmic<number, number> {\n    type: 'log'\n}\n\nexport interface ScaleSymlogSpec {\n    type: 'symlog'\n    constant?: number\n    min?: 'auto' | number\n    max?: 'auto' | number\n    round?: boolean\n    reverse?: boolean\n    nice?: boolean | number\n}\nexport interface ScaleSymlog extends D3ScaleSymLog<number, number> {\n    type: 'symlog'\n}\n\nexport type ScalePointSpec = {\n    type: 'point'\n}\nexport interface ScalePoint<Input extends StringValue> extends D3ScalePoint<Input> {\n    type: 'point'\n}\n\nexport type ScaleBandSpec = {\n    type: 'band'\n    round?: boolean\n}\nexport interface ScaleBand<Input extends StringValue> extends D3ScaleBand<Input> {\n    type: 'band'\n}\n\nexport type ScaleTimeSpec = {\n    type: 'time'\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    min?: 'auto' | Date | string\n    max?: 'auto' | Date | string\n    useUTC?: boolean\n    nice?: boolean\n}\n\nexport interface ScaleTime<Input> extends D3ScaleTime<Input, number> {\n    type: 'time'\n    useUTC: boolean\n}\n\nexport type AnyScale = Scale<any, any>\n\nexport type ScaleWithBandwidth = ScaleBand<any> | ScalePoint<any>\n\nexport type Series<XValue extends ScaleValue, YValue extends ScaleValue> = {\n    data: {\n        data: {\n            x: XValue | null\n            y: YValue | null\n        }\n    }[]\n}[]\n\n// A serie containing data for a specific axis\nexport type SerieAxis<Axis extends ScaleAxis, Value extends ScaleValue> = {\n    data: {\n        data: Record<Axis, Value | null>\n    }[]\n}[]\n\nexport type ComputedSerieAxis<Value extends ScaleValue> = {\n    all: readonly Value[]\n    min: Value\n    minStacked?: Value\n    max: Value\n    maxStacked?: Value\n}\n\nexport type TicksSpec<Value extends ScaleValue> =\n    // exact number of ticks, please note that\n    // depending on the current range of values,\n    // you might not get this exact count\n    | number\n    // string is used for Date based scales,\n    // it can express a time interval,\n    // for example: every 2 weeks\n    | string\n    // override scale ticks with custom explicit values\n    | readonly Value[]\n", "import { timeFormat } from 'd3-time-format'\nimport { format as d3Format } from 'd3-format'\n// @ts-expect-error no types\nimport { textPropsByEngine } from '@nivo/core'\nimport { ScaleValue, AnyScale, TicksSpec, getScaleTicks, centerScale } from '@nivo/scales'\nimport { Point, ValueFormatter, Line } from './types'\n\nconst isArray = <T>(value: unknown): value is T[] => Array.isArray(value)\n\nexport const computeCartesianTicks = <Value extends ScaleValue>({\n    axis,\n    scale,\n    ticksPosition,\n    tickValues,\n    tickSize,\n    tickPadding,\n    tickRotation,\n    truncateTickAt,\n    engine = 'svg',\n}: {\n    axis: 'x' | 'y'\n    scale: AnyScale\n    ticksPosition?: 'after' | 'before'\n    tickValues?: TicksSpec<Value>\n    tickSize: number\n    tickPadding: number\n    tickRotation: number\n    truncateTickAt?: number\n    engine?: 'svg' | 'canvas'\n}) => {\n    const values = getScaleTicks<Value>(scale, tickValues)\n\n    const textProps = textPropsByEngine[engine]\n\n    const position = 'bandwidth' in scale ? centerScale(scale) : scale\n    const line = { lineX: 0, lineY: 0 }\n    const text = { textX: 0, textY: 0 }\n\n    const isRTL = typeof document === 'object' ? document.dir === 'rtl' : false\n    let translate: (value: Value) => Point\n    let textAlign: CanvasTextAlign = textProps.align.center\n    let textBaseline: CanvasTextBaseline = textProps.baseline.center\n\n    if (axis === 'x') {\n        translate = d => ({ x: position(d) ?? 0, y: 0 })\n\n        line.lineY = tickSize * (ticksPosition === 'after' ? 1 : -1)\n        text.textY = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1)\n\n        if (ticksPosition === 'after') {\n            textBaseline = textProps.baseline.top\n        } else {\n            textBaseline = textProps.baseline.bottom\n        }\n\n        if (tickRotation === 0) {\n            textAlign = textProps.align.center\n        } else if (\n            (ticksPosition === 'after' && tickRotation < 0) ||\n            (ticksPosition === 'before' && tickRotation > 0)\n        ) {\n            textAlign = textProps.align[isRTL ? 'left' : 'right']\n            textBaseline = textProps.baseline.center\n        } else if (\n            (ticksPosition === 'after' && tickRotation > 0) ||\n            (ticksPosition === 'before' && tickRotation < 0)\n        ) {\n            textAlign = textProps.align[isRTL ? 'right' : 'left']\n            textBaseline = textProps.baseline.center\n        }\n    } else {\n        translate = d => ({ x: 0, y: position(d) ?? 0 })\n\n        line.lineX = tickSize * (ticksPosition === 'after' ? 1 : -1)\n        text.textX = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1)\n\n        if (ticksPosition === 'after') {\n            textAlign = textProps.align.left\n        } else {\n            textAlign = textProps.align.right\n        }\n    }\n\n    const truncateTick = (value: string) => {\n        const valueLength = String(value).length\n\n        if (truncateTickAt && truncateTickAt > 0 && valueLength > truncateTickAt) {\n            return `${String(value).slice(0, truncateTickAt).concat('...')}`\n        }\n        return `${value}`\n    }\n\n    const ticks = values.map((value: Value) => {\n        const processedValue =\n            typeof value === 'string' ? (truncateTick(value) as unknown as Value) : value\n        return {\n            key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n            value: processedValue,\n            ...translate(value),\n            ...line,\n            ...text,\n        }\n    })\n\n    return {\n        ticks,\n        textAlign,\n        textBaseline,\n    }\n}\n\nexport const getFormatter = <Value extends ScaleValue>(\n    format: string | ValueFormatter<Value> | undefined,\n    scale: AnyScale\n): ValueFormatter<Value> | undefined => {\n    if (typeof format === 'undefined' || typeof format === 'function') return format\n\n    if (scale.type === 'time') {\n        const formatter = timeFormat(format)\n\n        return ((d: any) => formatter(d instanceof Date ? d : new Date(d))) as ValueFormatter<Value>\n    }\n\n    return d3Format(format) as unknown as ValueFormatter<Value>\n}\n\nexport const computeGridLines = <Value extends ScaleValue>({\n    width,\n    height,\n    scale,\n    axis,\n    values: _values,\n}: {\n    width: number\n    height: number\n    scale: AnyScale\n    axis: 'x' | 'y'\n    values?: TicksSpec<Value>\n}) => {\n    const lineValues = isArray<number>(_values) ? _values : undefined\n    const values = lineValues || getScaleTicks<Value>(scale, _values)\n    const position = 'bandwidth' in scale ? centerScale(scale) : scale\n\n    const lines: Line[] =\n        axis === 'x'\n            ? values.map((value: Value) => ({\n                  key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n                  x1: position(value) ?? 0,\n                  x2: position(value) ?? 0,\n                  y1: 0,\n                  y2: height,\n              }))\n            : values.map((value: Value) => ({\n                  key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n                  x1: 0,\n                  x2: width,\n                  y1: position(value) ?? 0,\n                  y2: position(value) ?? 0,\n              }))\n\n    return lines\n}\n", "import { useMemo, memo } from 'react'\nimport * as React from 'react'\nimport { animated } from '@react-spring/web'\nimport { Text } from '@nivo/text'\nimport { ScaleValue } from '@nivo/scales'\nimport { AxisTickProps } from '../types'\n\nconst AxisTick = <Value extends ScaleValue>({\n    value: _value,\n    format,\n    lineX,\n    lineY,\n    onClick,\n    textBaseline,\n    textAnchor,\n    theme,\n    animatedProps,\n}: AxisTickProps<Value>) => {\n    const value = format?.(_value) ?? _value\n\n    const props = useMemo(() => {\n        const style = { opacity: animatedProps.opacity }\n\n        if (!onClick) {\n            return { style }\n        }\n\n        return {\n            style: { ...style, cursor: 'pointer' },\n            onClick: (event: React.MouseEvent<SVGGElement, MouseEvent>) => onClick(event, value),\n        }\n    }, [animatedProps.opacity, onClick, value])\n\n    return (\n        <animated.g transform={animatedProps.transform} {...props}>\n            <line x1={0} x2={lineX} y1={0} y2={lineY} style={theme.line} />\n            <Text\n                dominantBaseline={textBaseline}\n                textAnchor={textAnchor}\n                transform={animatedProps.textTransform}\n                style={theme.text}\n            >\n                {`${value}`}\n            </Text>\n        </animated.g>\n    )\n}\n\nconst memoizedAxisTick = memo(AxisTick) as typeof AxisTick\n\nexport { memoizedAxisTick as AxisTick }\n", "import { AxisProps } from './types'\n\nexport const defaultAxisProps: Pick<\n    Required<AxisProps>,\n    'tickSize' | 'tickPadding' | 'tickRotation' | 'legendPosition' | 'legendOffset'\n> = {\n    tickSize: 5,\n    tickPadding: 5,\n    tickRotation: 0,\n    legendPosition: 'middle',\n    legendOffset: 0,\n}\n", "import { useMotionConfig } from '@nivo/core'\nimport { useTheme, useExtendedAxisTheme } from '@nivo/theming'\nimport { Text } from '@nivo/text'\nimport { AnyScale, ScaleValue } from '@nivo/scales'\nimport { animated, useSpring, useTransition } from '@react-spring/web'\nimport * as React from 'react'\nimport { memo, useCallback, useMemo } from 'react'\nimport { computeCartesianTicks, getFormatter } from '../compute'\nimport { AxisProps } from '../types'\nimport { AxisTick } from './AxisTick'\nimport { defaultAxisProps } from '../defaults'\n\nexport const NonMemoizedAxis = <Value extends ScaleValue>({\n    axis,\n    scale,\n    x = 0,\n    y = 0,\n    length,\n    ticksPosition,\n    tickValues,\n    tickSize = defaultAxisProps.tickSize,\n    tickPadding = defaultAxisProps.tickPadding,\n    tickRotation = defaultAxisProps.tickRotation,\n    format,\n    renderTick = AxisTick,\n    truncateTickAt,\n    legend,\n    legendPosition = defaultAxisProps.legendPosition,\n    legendOffset = defaultAxisProps.legendOffset,\n    style,\n    onClick,\n    ariaHidden,\n}: AxisProps<Value> & {\n    axis: 'x' | 'y'\n    scale: AnyScale\n    x?: number\n    y?: number\n    length: number\n    onClick?: (event: React.MouseEvent<SVGGElement, MouseEvent>, value: Value | string) => void\n}) => {\n    const theme = useTheme()\n    const axisTheme = useExtendedAxisTheme(theme.axis, style)\n\n    const formatValue = useMemo(() => getFormatter(format, scale), [format, scale])\n\n    const { ticks, textAlign, textBaseline } = computeCartesianTicks({\n        axis,\n        scale,\n        ticksPosition,\n        tickValues,\n        tickSize,\n        tickPadding,\n        tickRotation,\n        truncateTickAt,\n    })\n\n    let legendNode = null\n    if (legend !== undefined) {\n        let legendX = 0\n        let legendY = 0\n        let legendRotation = 0\n        let textAnchor\n\n        if (axis === 'y') {\n            legendRotation = -90\n            legendX = legendOffset\n            if (legendPosition === 'start') {\n                textAnchor = 'start'\n                legendY = length\n            } else if (legendPosition === 'middle') {\n                textAnchor = 'middle'\n                legendY = length / 2\n            } else if (legendPosition === 'end') {\n                textAnchor = 'end'\n            }\n        } else {\n            legendY = legendOffset\n            if (legendPosition === 'start') {\n                textAnchor = 'start'\n            } else if (legendPosition === 'middle') {\n                textAnchor = 'middle'\n                legendX = length / 2\n            } else if (legendPosition === 'end') {\n                textAnchor = 'end'\n                legendX = length\n            }\n        }\n\n        legendNode = (\n            <>\n                <Text\n                    transform={`translate(${legendX}, ${legendY}) rotate(${legendRotation})`}\n                    textAnchor={textAnchor}\n                    style={{\n                        ...axisTheme.legend.text,\n                        dominantBaseline: 'central',\n                    }}\n                >\n                    {legend}\n                </Text>\n            </>\n        )\n    }\n\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        transform: `translate(${x},${y})`,\n        lineX2: axis === 'x' ? length : 0,\n        lineY2: axis === 'x' ? 0 : length,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    const getAnimatedProps = useCallback(\n        (tick: (typeof ticks)[0]) => {\n            return {\n                opacity: 1,\n                transform: `translate(${tick.x},${tick.y})`,\n                textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n            }\n        },\n        [tickRotation]\n    )\n    const getFromAnimatedProps = useCallback(\n        (tick: (typeof ticks)[0]) => ({\n            opacity: 0,\n            transform: `translate(${tick.x},${tick.y})`,\n            textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n        }),\n        [tickRotation]\n    )\n\n    const transition = useTransition<\n        (typeof ticks)[0],\n        { opacity: number; transform: string; textTransform: string }\n    >(ticks, {\n        keys: tick => tick.key,\n        initial: getAnimatedProps,\n        from: getFromAnimatedProps,\n        enter: getAnimatedProps,\n        update: getAnimatedProps,\n        leave: {\n            opacity: 0,\n        },\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.g transform={animatedProps.transform} aria-hidden={ariaHidden}>\n            {transition((transitionProps, tick, _state, tickIndex) => {\n                return React.createElement(renderTick, {\n                    tickIndex,\n                    format: formatValue,\n                    rotate: tickRotation,\n                    textBaseline,\n                    textAnchor: textAlign,\n                    truncateTickAt: truncateTickAt,\n                    animatedProps: transitionProps,\n                    theme: axisTheme.ticks,\n                    ...tick,\n                    ...(onClick ? { onClick } : {}),\n                })\n            })}\n            <animated.line\n                style={axisTheme.domain.line}\n                x1={0}\n                x2={animatedProps.lineX2}\n                y1={0}\n                y2={animatedProps.lineY2}\n            />\n            {legendNode}\n        </animated.g>\n    )\n}\n\nexport const Axis = memo(NonMemoizedAxis) as typeof NonMemoizedAxis\n", "export const positions = ['top', 'right', 'bottom', 'left'] as const\n", "import { memo } from 'react'\nimport { ScaleValue, AnyScale } from '@nivo/scales'\nimport { Axis } from './Axis'\nimport { positions } from '../props'\nimport { AxisProps } from '../types'\n\nexport const Axes = memo(\n    <X extends ScaleValue, Y extends ScaleValue>({\n        xScale,\n        yScale,\n        width,\n        height,\n        top,\n        right,\n        bottom,\n        left,\n    }: {\n        xScale: AnyScale\n        yScale: AnyScale\n        width: number\n        height: number\n        top?: AxisProps<X> | null\n        right?: AxisProps<Y> | null\n        bottom?: AxisProps<X> | null\n        left?: AxisProps<Y> | null\n    }) => {\n        const axes = { top, right, bottom, left }\n\n        return (\n            <>\n                {positions.map(position => {\n                    const axis = axes[position] as typeof position extends 'bottom' | 'top'\n                        ? AxisProps<X> | undefined\n                        : AxisProps<Y> | undefined\n\n                    if (!axis) return null\n\n                    const isXAxis = position === 'top' || position === 'bottom'\n                    const ticksPosition =\n                        position === 'top' || position === 'left' ? 'before' : 'after'\n\n                    return (\n                        <Axis\n                            key={position}\n                            {...axis}\n                            axis={isXAxis ? 'x' : 'y'}\n                            x={position === 'right' ? width : 0}\n                            y={position === 'bottom' ? height : 0}\n                            scale={isXAxis ? xScale : yScale}\n                            length={isXAxis ? width : height}\n                            ticksPosition={ticksPosition}\n                            truncateTickAt={axis.truncateTickAt}\n                        />\n                    )\n                })}\n            </>\n        )\n    }\n)\n", "import { memo, SVGAttributes } from 'react'\nimport { SpringValues, animated } from '@react-spring/web'\nimport { useTheme } from '@nivo/theming'\n\nexport const GridLine = memo(\n    ({\n        animatedProps,\n    }: {\n        animatedProps: SpringValues<{\n            opacity: number\n            x1: number\n            x2: number\n            y1: number\n            y2: number\n        }>\n    }) => {\n        const theme = useTheme()\n\n        return (\n            <animated.line\n                {...animatedProps}\n                {...(theme.grid.line as SVGAttributes<SVGLineElement>)}\n            />\n        )\n    }\n)\n", "import { memo } from 'react'\nimport { useTransition } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { GridLine } from './GridLine'\nimport { Line } from '../types'\n\nexport const GridLines = memo(({ lines }: { lines: Line[] }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const transition = useTransition<Line, Record<'opacity' | 'x1' | 'x2' | 'y1' | 'y2', number>>(\n        lines,\n        {\n            keys: line => line.key,\n            initial: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            from: line => ({\n                opacity: 0,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            enter: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            update: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            leave: {\n                opacity: 0,\n            },\n            config: springConfig,\n            immediate: !animate,\n        }\n    )\n\n    return (\n        <g>\n            {transition((animatedProps, line) => (\n                <GridLine {...line} key={line.key} animatedProps={animatedProps} />\n            ))}\n        </g>\n    )\n})\n", "import { useMemo, memo } from 'react'\nimport { ScaleValue, AnyScale, TicksSpec } from '@nivo/scales'\nimport { GridLines } from './GridLines'\nimport { computeGridLines } from '../compute'\n\nexport const Grid = memo(\n    <X extends ScaleValue, Y extends ScaleValue>({\n        width,\n        height,\n        xScale,\n        yScale,\n        xValues,\n        yValues,\n    }: {\n        width: number\n        height: number\n        xScale?: AnyScale | null\n        xValues?: TicksSpec<X>\n        yScale?: AnyScale | null\n        yValues?: TicksSpec<Y>\n    }) => {\n        const xLines = useMemo(() => {\n            if (!xScale) return false\n\n            return computeGridLines({\n                width,\n                height,\n                scale: xScale,\n                axis: 'x',\n                values: xValues,\n            })\n        }, [xScale, xValues, width, height])\n\n        const yLines = useMemo(() => {\n            if (!yScale) return false\n\n            return computeGridLines({\n                width,\n                height,\n                scale: yScale,\n                axis: 'y',\n                values: yValues,\n            })\n        }, [height, width, yScale, yValues])\n\n        return (\n            <>\n                {xLines && <GridLines lines={xLines} />}\n                {yLines && <GridLines lines={yLines} />}\n            </>\n        )\n    }\n)\n", "import { degreesToRadians } from '@nivo/core'\nimport { Theme, PartialTheme, extendAxisTheme } from '@nivo/theming'\nimport { setCanvasFont, drawCanvasText } from '@nivo/text'\nimport { ScaleValue, AnyScale, TicksSpec } from '@nivo/scales'\nimport { defaultAxisProps } from './defaults'\nimport { computeCartesianTicks, getFormatter, computeGridLines } from './compute'\nimport { positions } from './props'\nimport { AxisLegendPosition, CanvasAxisProps, ValueFormatter } from './types'\n\nexport const renderAxisToCanvas = <Value extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        axis,\n        scale,\n        x = 0,\n        y = 0,\n        length,\n        ticksPosition,\n        tickValues,\n        tickSize = defaultAxisProps.tickSize,\n        tickPadding = defaultAxisProps.tickPadding,\n        tickRotation = defaultAxisProps.tickRotation,\n        format: _format,\n        legend,\n        legendPosition = defaultAxisProps.legendPosition,\n        legendOffset = defaultAxisProps.legendOffset,\n        theme,\n        style,\n    }: {\n        axis: 'x' | 'y'\n        scale: AnyScale\n        x?: number\n        y?: number\n        length: number\n        ticksPosition: 'before' | 'after'\n        tickValues?: TicksSpec<Value>\n        tickSize?: number\n        tickPadding?: number\n        tickRotation?: number\n        format?: string | ValueFormatter<Value>\n        legend?: string\n        legendPosition?: AxisLegendPosition\n        legendOffset?: number\n        theme: Theme\n        style?: PartialTheme['axis']\n    }\n) => {\n    const { ticks, textAlign, textBaseline } = computeCartesianTicks({\n        axis,\n        scale,\n        ticksPosition,\n        tickValues,\n        tickSize,\n        tickPadding,\n        tickRotation,\n        engine: 'canvas',\n    })\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    const axisTheme = extendAxisTheme(theme.axis, style)\n\n    ctx.textAlign = textAlign\n    ctx.textBaseline = textBaseline\n\n    setCanvasFont(ctx, axisTheme.ticks.text)\n\n    const domainLineWidth = axisTheme.domain.line.strokeWidth ?? 0\n    if (typeof domainLineWidth !== 'string' && domainLineWidth > 0) {\n        ctx.lineWidth = domainLineWidth\n        ctx.lineCap = 'square'\n\n        if (axisTheme.domain.line.stroke) {\n            ctx.strokeStyle = axisTheme.domain.line.stroke\n        }\n\n        ctx.beginPath()\n        ctx.moveTo(0, 0)\n        ctx.lineTo(axis === 'x' ? length : 0, axis === 'x' ? 0 : length)\n        ctx.stroke()\n    }\n\n    const format = typeof _format === 'function' ? _format : (value: unknown) => `${value}`\n\n    const tickLineWidth = axisTheme.ticks.line.strokeWidth ?? 0\n    const shouldRenderTickLine = typeof tickLineWidth !== 'string' && tickLineWidth > 0\n    ticks.forEach(tick => {\n        if (shouldRenderTickLine) {\n            ctx.lineWidth = tickLineWidth\n            ctx.lineCap = 'square'\n\n            if (axisTheme.ticks.line.stroke) {\n                ctx.strokeStyle = axisTheme.ticks.line.stroke\n            }\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x, tick.y)\n            ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY)\n            ctx.stroke()\n        }\n\n        const value = format(tick.value)\n\n        ctx.save()\n        ctx.translate(tick.x + tick.textX, tick.y + tick.textY)\n        ctx.rotate(degreesToRadians(tickRotation))\n\n        drawCanvasText(ctx, axisTheme.ticks.text, `${value}`)\n\n        ctx.fillText(`${value}`, 0, 0)\n        ctx.restore()\n    })\n\n    if (legend !== undefined) {\n        let legendX = 0\n        let legendY = 0\n        let legendRotation = 0\n        let textAlign: CanvasTextAlign = 'center'\n\n        if (axis === 'y') {\n            legendRotation = -90\n            legendX = legendOffset\n            if (legendPosition === 'start') {\n                textAlign = 'start'\n                legendY = length\n            } else if (legendPosition === 'middle') {\n                textAlign = 'center'\n                legendY = length / 2\n            } else if (legendPosition === 'end') {\n                textAlign = 'end'\n            }\n        } else {\n            legendY = legendOffset\n            if (legendPosition === 'start') {\n                textAlign = 'start'\n            } else if (legendPosition === 'middle') {\n                textAlign = 'center'\n                legendX = length / 2\n            } else if (legendPosition === 'end') {\n                textAlign = 'end'\n                legendX = length\n            }\n        }\n\n        ctx.translate(legendX, legendY)\n        ctx.rotate(degreesToRadians(legendRotation))\n        setCanvasFont(ctx, axisTheme.legend.text)\n\n        if (axisTheme.legend.text.fill) {\n            ctx.fillStyle = axisTheme.legend.text.fill\n        }\n\n        ctx.textAlign = textAlign\n        ctx.textBaseline = 'middle'\n        drawCanvasText(ctx, axisTheme.legend.text, legend)\n    }\n\n    ctx.restore()\n}\n\nexport const renderAxesToCanvas = <X extends ScaleValue, Y extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        xScale,\n        yScale,\n        width,\n        height,\n        top,\n        right,\n        bottom,\n        left,\n        theme,\n    }: {\n        xScale: AnyScale\n        yScale: AnyScale\n        width: number\n        height: number\n        top?: CanvasAxisProps<X> | null\n        right?: CanvasAxisProps<Y> | null\n        bottom?: CanvasAxisProps<X> | null\n        left?: CanvasAxisProps<Y> | null\n        theme: Theme\n    }\n) => {\n    const axes = { top, right, bottom, left }\n\n    positions.forEach(position => {\n        const axis = axes[position] as typeof position extends 'bottom' | 'top'\n            ? CanvasAxisProps<X> | undefined\n            : CanvasAxisProps<Y> | undefined\n\n        if (!axis) return null\n\n        const isXAxis = position === 'top' || position === 'bottom'\n        const ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after'\n        const scale = isXAxis ? xScale : yScale\n        const format = getFormatter(axis.format, scale)\n\n        renderAxisToCanvas(ctx, {\n            ...axis,\n            axis: isXAxis ? 'x' : 'y',\n            x: position === 'right' ? width : 0,\n            y: position === 'bottom' ? height : 0,\n            scale,\n            format,\n            length: isXAxis ? width : height,\n            ticksPosition,\n            theme,\n        })\n    })\n}\n\nexport const renderGridLinesToCanvas = <Value extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        width,\n        height,\n        scale,\n        axis,\n        values,\n    }: {\n        width: number\n        height: number\n        scale: AnyScale\n        axis: 'x' | 'y'\n        values?: TicksSpec<Value>\n    }\n) => {\n    const lines = computeGridLines({ width, height, scale, axis, values })\n\n    lines.forEach(line => {\n        ctx.beginPath()\n        ctx.moveTo(line.x1, line.y1)\n        ctx.lineTo(line.x2, line.y2)\n        ctx.stroke()\n    })\n}\n", "export const defaultProps = {\n    dotSize: 4,\n    noteWidth: 120,\n    noteTextOffset: 8,\n    animate: true,\n}\n", "import {\n    AnnotationSpec,\n    CircleAnnotationSpec,\n    DotAnnotationSpec,\n    Note,\n    NoteCanvas,\n    NoteSvg,\n    RectAnnotationSpec,\n} from './types'\nimport { isValidElement } from 'react'\n\nexport const isSvgNote = <Datum>(note: Note<Datum>): note is NoteSvg<Datum> => {\n    const noteType = typeof note\n\n    return (\n        isValidElement(note) ||\n        noteType === 'string' ||\n        noteType === 'function' ||\n        noteType === 'object'\n    )\n}\n\nexport const isCanvasNote = <Datum>(note: Note<Datum>): note is NoteCanvas<Datum> => {\n    const noteType = typeof note\n\n    return noteType === 'string' || noteType === 'function'\n}\n\nexport const isCircleAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is CircleAnnotationSpec<Datum> => annotationSpec.type === 'circle'\n\nexport const isDotAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is DotAnnotationSpec<Datum> => annotationSpec.type === 'dot'\n\nexport const isRectAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is RectAnnotationSpec<Datum> => annotationSpec.type === 'rect'\n", "import filter from 'lodash/filter.js'\nimport isNumber from 'lodash/isNumber.js'\nimport omit from 'lodash/omit.js'\nimport {\n    radiansToDegrees,\n    normalizeAngleDegrees,\n    degreesToRadians,\n    positionFromAngle,\n} from '@nivo/core'\nimport { defaultProps } from './props'\nimport {\n    AnnotationPositionGetter,\n    AnnotationDimensionsGetter,\n    BoundAnnotation,\n    AnnotationMatcher,\n    AnnotationInstructions,\n} from './types'\nimport { isCircleAnnotation, isRectAnnotation } from './utils'\n\nexport const bindAnnotations = <\n    Datum = {\n        x: number\n        y: number\n    },\n>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: readonly Datum[]\n    annotations: readonly AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}): BoundAnnotation<Datum>[] =>\n    annotations.reduce((acc: BoundAnnotation<Datum>[], annotation) => {\n        const offset = annotation.offset || 0\n\n        return [\n            ...acc,\n            ...filter<Datum>(data, annotation.match).map(datum => {\n                const position = getPosition(datum)\n                const dimensions = getDimensions(datum)\n\n                if (isCircleAnnotation(annotation) || isRectAnnotation(annotation)) {\n                    dimensions.size = dimensions.size + offset * 2\n                    dimensions.width = dimensions.width + offset * 2\n                    dimensions.height = dimensions.height + offset * 2\n                }\n\n                // acc.push({\n                //     ...omit(annotation, ['match', 'offset']),\n                //     ...position,\n                //     ...dimensions,\n                //     size: annotation.size || dimensions.size,\n                //     datum,\n                // } as any)\n                // return [\n                //     ...acc,\n                //     {\n                //         ...omit(annotation, ['match', 'offset']),\n                //         ...position,\n                //         ...dimensions,\n                //         size: annotation.size || dimensions.size,\n                //         datum,\n                //     },\n                // ]\n                return {\n                    ...omit(annotation, ['match', 'offset']),\n                    ...position,\n                    ...dimensions,\n                    size: annotation.size || dimensions.size,\n                    datum,\n                } as Required<BoundAnnotation<Datum>>\n            }),\n        ]\n\n        // return acc\n    }, [])\n\nexport const getLinkAngle = (\n    sourceX: number,\n    sourceY: number,\n    targetX: number,\n    targetY: number\n) => {\n    const angle = Math.atan2(targetY - sourceY, targetX - sourceX)\n\n    return normalizeAngleDegrees(radiansToDegrees(angle))\n}\n\nexport const computeAnnotation = <Datum>(\n    annotation: BoundAnnotation<Datum>\n): AnnotationInstructions => {\n    const {\n        x,\n        y,\n        noteX,\n        noteY,\n        noteWidth = defaultProps.noteWidth,\n        noteTextOffset = defaultProps.noteTextOffset,\n    } = annotation\n\n    let computedNoteX: number\n    let computedNoteY: number\n\n    if (isNumber(noteX)) {\n        computedNoteX = x + noteX\n    } else if (noteX.abs !== undefined) {\n        computedNoteX = noteX.abs\n    } else {\n        throw new Error(`noteX should be either a number or an object containing an 'abs' property`)\n    }\n\n    if (isNumber(noteY)) {\n        computedNoteY = y + noteY\n    } else if (noteY.abs !== undefined) {\n        computedNoteY = noteY.abs\n    } else {\n        throw new Error(`noteY should be either a number or an object containing an 'abs' property`)\n    }\n\n    let computedX = x\n    let computedY = y\n\n    const angle = getLinkAngle(x, y, computedNoteX, computedNoteY)\n\n    if (isCircleAnnotation<Datum>(annotation)) {\n        const position = positionFromAngle(degreesToRadians(angle), annotation.size / 2)\n        computedX += position.x\n        computedY += position.y\n    }\n\n    if (isRectAnnotation<Datum>(annotation)) {\n        const eighth = Math.round((angle + 90) / 45) % 8\n        if (eighth === 0) {\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 1) {\n            computedX += annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 2) {\n            computedX += annotation.width / 2\n        }\n        if (eighth === 3) {\n            computedX += annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 4) {\n            computedY += annotation.height / 2\n        }\n        if (eighth === 5) {\n            computedX -= annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 6) {\n            computedX -= annotation.width / 2\n        }\n        if (eighth === 7) {\n            computedX -= annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n    }\n\n    let textX = computedNoteX\n    const textY = computedNoteY - noteTextOffset\n\n    let noteLineX = computedNoteX\n    const noteLineY = computedNoteY\n\n    if ((angle + 90) % 360 > 180) {\n        textX -= noteWidth\n        noteLineX -= noteWidth\n    } else {\n        noteLineX += noteWidth\n    }\n\n    return {\n        points: [\n            [computedX, computedY],\n            [computedNoteX, computedNoteY],\n            [noteLineX, noteLineY],\n        ] as [number, number][],\n        text: [textX, textY],\n        angle: angle + 90,\n    }\n}\n", "import { useMemo } from 'react'\nimport { bindAnnotations, computeAnnotation } from './compute'\nimport {\n    AnnotationDimensionsGetter,\n    AnnotationMatcher,\n    AnnotationPositionGetter,\n    BoundAnnotation,\n} from './types'\n\n/**\n * Bind annotations to a dataset.\n */\nexport const useAnnotations = <Datum>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: readonly Datum[]\n    annotations: readonly AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}) =>\n    useMemo(\n        () =>\n            bindAnnotations<Datum>({\n                data,\n                annotations,\n                getPosition,\n                getDimensions,\n            }),\n        [data, annotations, getPosition, getDimensions]\n    )\n\nexport const useComputedAnnotations = <Datum>({\n    annotations,\n}: {\n    annotations: readonly BoundAnnotation<Datum>[]\n}) =>\n    useMemo(\n        () =>\n            annotations.map(annotation => ({\n                ...annotation,\n                computed: computeAnnotation<Datum>({\n                    ...annotation,\n                }),\n            })),\n        [annotations]\n    )\n\nexport const useComputedAnnotation = <Datum>(annotation: BoundAnnotation<Datum>) =>\n    useMemo(() => computeAnnotation<Datum>(annotation), [annotation])\n", "import { createElement } from 'react'\nimport omit from 'lodash/omit.js'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport { NoteSvg } from './types'\n\nexport const AnnotationNote = <Datum,>({\n    datum,\n    x,\n    y,\n    note,\n}: {\n    datum: Datum\n    x: number\n    y: number\n    note: NoteSvg<Datum>\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    if (typeof note === 'function') {\n        return createElement(note, { x, y, datum })\n    }\n\n    return (\n        <>\n            {theme.annotations.text.outlineWidth > 0 && (\n                <animated.text\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    style={{\n                        ...theme.annotations.text,\n                        strokeLinejoin: 'round',\n                        strokeWidth: theme.annotations.text.outlineWidth * 2,\n                        stroke: theme.annotations.text.outlineColor,\n                    }}\n                >\n                    {note}\n                </animated.text>\n            )}\n            <animated.text\n                x={animatedProps.x}\n                y={animatedProps.y}\n                style={omit(theme.annotations.text, ['outlineWidth', 'outlineColor'])}\n            >\n                {note}\n            </animated.text>\n        </>\n    )\n}\n", "import { useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\n\nexport const AnnotationLink = ({\n    points,\n    isOutline = false,\n}: {\n    points: [number, number][]\n    isOutline?: boolean\n}) => {\n    const theme = useTheme()\n\n    const path = useMemo(() => {\n        const [firstPoint, ...otherPoints] = points\n\n        return otherPoints.reduce(\n            (acc, [x, y]) => `${acc} L${x},${y}`,\n            `M${firstPoint[0]},${firstPoint[1]}`\n        )\n    }, [points])\n\n    const animatedPath = useAnimatedPath(path)\n\n    if (isOutline && theme.annotations.link.outlineWidth <= 0) {\n        return null\n    }\n\n    const style = { ...theme.annotations.link }\n    if (isOutline) {\n        style.strokeLinecap = 'square'\n        style.strokeWidth =\n            theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n        style.stroke = theme.annotations.link.outlineColor\n        style.opacity = theme.annotations.link.outlineOpacity\n    }\n\n    return <animated.path fill=\"none\" d={animatedPath} style={style} />\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\n\nexport const CircleAnnotationOutline = ({ x, y, size }: { x: number; y: number; size: number }) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport { defaultProps } from './props'\n\nexport const DotAnnotationOutline = ({\n    x,\n    y,\n    size = defaultProps.dotSize,\n}: {\n    x: number\n    y: number\n    size?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth: theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.symbol}\n            />\n        </>\n    )\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\n\nexport const RectAnnotationOutline = ({\n    x,\n    y,\n    width,\n    height,\n    borderRadius = 6,\n}: {\n    x: number\n    y: number\n    width: number\n    height: number\n    borderRadius?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x: x - width / 2,\n        y: y - height / 2,\n        width,\n        height,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.rect\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    rx={borderRadius}\n                    ry={borderRadius}\n                    width={animatedProps.width}\n                    height={animatedProps.height}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.rect\n                x={animatedProps.x}\n                y={animatedProps.y}\n                rx={borderRadius}\n                ry={borderRadius}\n                width={animatedProps.width}\n                height={animatedProps.height}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n", "import { useComputedAnnotation } from './hooks'\nimport { AnnotationNote } from './AnnotationNote'\nimport { AnnotationLink } from './AnnotationLink'\nimport { CircleAnnotationOutline } from './CircleAnnotationOutline'\nimport { DotAnnotationOutline } from './DotAnnotationOutline'\nimport { RectAnnotationOutline } from './RectAnnotationOutline'\nimport { BoundAnnotation } from './types'\nimport { isCircleAnnotation, isDotAnnotation, isRectAnnotation, isSvgNote } from './utils'\n\nexport const Annotation = <Datum,>(annotation: BoundAnnotation<Datum>) => {\n    const { datum, x, y, note } = annotation\n    const computed = useComputedAnnotation(annotation)\n\n    if (!isSvgNote(note)) {\n        throw new Error('note should be a valid react element')\n    }\n\n    return (\n        <>\n            <AnnotationLink points={computed.points} isOutline={true} />\n            {isCircleAnnotation(annotation) && (\n                <CircleAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isDotAnnotation(annotation) && (\n                <DotAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isRectAnnotation(annotation) && (\n                <RectAnnotationOutline\n                    x={x}\n                    y={y}\n                    width={annotation.width}\n                    height={annotation.height}\n                    borderRadius={annotation.borderRadius}\n                />\n            )}\n            <AnnotationLink points={computed.points} />\n            <AnnotationNote datum={datum} x={computed.text[0]} y={computed.text[1]} note={note} />\n        </>\n    )\n}\n", "import { Theme } from '@nivo/theming'\nimport { ComputedAnnotation } from './types'\nimport { isCanvasNote, isCircleAnnotation, isDotAnnotation, isRectAnnotation } from './utils'\n\nconst drawPoints = (ctx: CanvasRenderingContext2D, points: [number, number][]) => {\n    points.forEach(([x, y], index) => {\n        if (index === 0) {\n            ctx.moveTo(x, y)\n        } else {\n            ctx.lineTo(x, y)\n        }\n    })\n}\n\nexport const renderAnnotationsToCanvas = <Datum>(\n    ctx: CanvasRenderingContext2D,\n    {\n        annotations,\n        theme,\n    }: {\n        annotations: ComputedAnnotation<Datum>[]\n        theme: Theme\n    }\n) => {\n    if (annotations.length === 0) return\n\n    ctx.save()\n    annotations.forEach(annotation => {\n        if (!isCanvasNote(annotation.note)) {\n            throw new Error('note is invalid for canvas implementation')\n        }\n\n        if (theme.annotations.link.outlineWidth > 0) {\n            ctx.lineCap = 'square'\n            ctx.strokeStyle = theme.annotations.link.outlineColor\n            ctx.lineWidth =\n                theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n            ctx.beginPath()\n            drawPoints(ctx, annotation.computed.points)\n            ctx.stroke()\n            ctx.lineCap = 'butt'\n        }\n\n        if (isCircleAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation) && theme.annotations.symbol.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.symbol.outlineColor\n            ctx.lineWidth = theme.annotations.symbol.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isRectAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        ctx.strokeStyle = theme.annotations.link.stroke\n        ctx.lineWidth = theme.annotations.link.strokeWidth\n        ctx.beginPath()\n        drawPoints(ctx, annotation.computed.points)\n        ctx.stroke()\n\n        if (isCircleAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation)) {\n            ctx.fillStyle = theme.annotations.symbol.fill\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.fill()\n        }\n\n        if (isRectAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        if (typeof annotation.note === 'function') {\n            annotation.note(ctx, {\n                datum: annotation.datum,\n                x: annotation.computed.text[0],\n                y: annotation.computed.text[1],\n                theme,\n            })\n        } else {\n            ctx.font = `${theme.annotations.text.fontSize}px ${theme.annotations.text.fontFamily}`\n            ctx.textAlign = 'left'\n            ctx.textBaseline = 'alphabetic'\n\n            ctx.fillStyle = theme.annotations.text.fill\n            ctx.strokeStyle = theme.annotations.text.outlineColor\n            ctx.lineWidth = theme.annotations.text.outlineWidth * 2\n\n            if (theme.annotations.text.outlineWidth > 0) {\n                ctx.lineJoin = 'round'\n                ctx.strokeText(\n                    annotation.note,\n                    annotation.computed.text[0],\n                    annotation.computed.text[1]\n                )\n                ctx.lineJoin = 'miter'\n            }\n            ctx.fillText(annotation.note, annotation.computed.text[0], annotation.computed.text[1])\n        }\n    })\n    ctx.restore()\n}\n", "export const roundedRect = (\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    radius: number\n) => {\n    if (radius > 0) {\n        ctx.moveTo(x + radius, y)\n        ctx.lineTo(x + width - radius, y)\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius)\n        ctx.lineTo(x + width, y + height - radius)\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height)\n        ctx.lineTo(x + radius, y + height)\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius)\n        ctx.lineTo(x, y + radius)\n        ctx.quadraticCurveTo(x, y, x + radius, y)\n        ctx.closePath()\n    } else {\n        ctx.rect(x, y, width, height)\n    }\n}\n", "import { Annotation, useAnnotations } from '@nivo/annotations'\nimport { BarAnnotationsProps, BarDatum } from './types'\n\nexport const BarAnnotations = <D extends BarDatum>({\n    bars,\n    annotations,\n}: BarAnnotationsProps<D>) => {\n    const boundAnnotations = useAnnotations({\n        data: bars,\n        annotations,\n        getPosition: bar => ({\n            x: bar.x + bar.width / 2,\n            y: bar.y + bar.height / 2,\n        }),\n        getDimensions: ({ height, width }) => ({\n            width,\n            height,\n            size: Math.max(width, height),\n        }),\n    })\n\n    return (\n        <>\n            {boundAnnotations.map((annotation, i) => (\n                <Annotation key={i} {...annotation} />\n            ))}\n        </>\n    )\n}\n", "import { BoxLegendSvg } from '@nivo/legends'\nimport { BarLegendProps, LegendData } from './types'\n\ninterface BarLegendsProps {\n    width: number\n    height: number\n    legends: [BarLegendProps, LegendData[]][]\n    toggleSerie: (id: string | number) => void\n}\n\nexport const BarLegends = ({ width, height, legends, toggleSerie }: BarLegendsProps) => (\n    <>\n        {legends.map(([legend, data], i) => (\n            <BoxLegendSvg\n                key={i}\n                {...legend}\n                containerWidth={width}\n                containerHeight={height}\n                data={legend.data ?? data}\n                toggleSerie={\n                    legend.toggleSerie && legend.dataFrom === 'keys' ? toggleSerie : undefined\n                }\n            />\n        ))}\n    </>\n)\n", "import { createElement, MouseEvent, useCallback, useMemo } from 'react'\nimport { animated, to } from '@react-spring/web'\nimport { useTheme } from '@nivo/theming'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Text } from '@nivo/text'\nimport { BarDatum, BarItemProps } from './types'\n\nexport const BarItem = <D extends BarDatum>({\n    bar: { data, ...bar },\n    style: {\n        borderColor,\n        color,\n        height,\n        labelColor,\n        labelOpacity,\n        labelX,\n        labelY,\n        transform,\n        width,\n        textAnchor,\n    },\n    borderRadius,\n    borderWidth,\n    label,\n    shouldRenderLabel,\n    isInteractive,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    tooltip,\n    isFocusable,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    ariaDisabled,\n    ariaHidden,\n}: BarItemProps<D>) => {\n    const theme = useTheme()\n    const { showTooltipFromEvent, showTooltipAt, hideTooltip } = useTooltip()\n\n    const renderTooltip = useMemo(\n        () => () => createElement(tooltip, { ...bar, ...data }),\n        [tooltip, bar, data]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onClick?.({ color: bar.color, ...data }, event)\n        },\n        [bar, data, onClick]\n    )\n    const handleTooltip = useCallback(\n        (event: MouseEvent<SVGRectElement>) => showTooltipFromEvent(renderTooltip(), event),\n        [showTooltipFromEvent, renderTooltip]\n    )\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseEnter?.(data, event)\n            showTooltipFromEvent(renderTooltip(), event)\n        },\n        [data, onMouseEnter, showTooltipFromEvent, renderTooltip]\n    )\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<SVGRectElement>) => {\n            onMouseLeave?.(data, event)\n            hideTooltip()\n        },\n        [data, hideTooltip, onMouseLeave]\n    )\n\n    // extra handlers to allow keyboard navigation\n    const handleFocus = useCallback(() => {\n        showTooltipAt(renderTooltip(), [bar.absX + bar.width / 2, bar.absY])\n    }, [showTooltipAt, renderTooltip, bar])\n    const handleBlur = useCallback(() => {\n        hideTooltip()\n    }, [hideTooltip])\n\n    return (\n        <animated.g transform={transform}>\n            <animated.rect\n                width={to(width, value => Math.max(value, 0))}\n                height={to(height, value => Math.max(value, 0))}\n                rx={borderRadius}\n                ry={borderRadius}\n                fill={data.fill ?? color}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                focusable={isFocusable}\n                tabIndex={isFocusable ? 0 : undefined}\n                aria-label={ariaLabel ? ariaLabel(data) : undefined}\n                aria-labelledby={ariaLabelledBy ? ariaLabelledBy(data) : undefined}\n                aria-describedby={ariaDescribedBy ? ariaDescribedBy(data) : undefined}\n                aria-disabled={ariaDisabled ? ariaDisabled(data) : undefined}\n                aria-hidden={ariaHidden ? ariaHidden(data) : undefined}\n                onMouseEnter={isInteractive ? handleMouseEnter : undefined}\n                onMouseMove={isInteractive ? handleTooltip : undefined}\n                onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n                onClick={isInteractive ? handleClick : undefined}\n                onFocus={isInteractive && isFocusable ? handleFocus : undefined}\n                onBlur={isInteractive && isFocusable ? handleBlur : undefined}\n                data-testid={`bar.item.${data.id}.${data.index}`}\n            />\n            {shouldRenderLabel && (\n                <Text\n                    x={labelX}\n                    y={labelY}\n                    textAnchor={textAnchor}\n                    dominantBaseline=\"central\"\n                    fillOpacity={labelOpacity}\n                    style={{\n                        ...theme.labels.text,\n                        // We don't want the label to intercept mouse events\n                        pointerEvents: 'none',\n                        fill: labelColor,\n                    }}\n                >\n                    {label}\n                </Text>\n            )}\n        </animated.g>\n    )\n}\n", "import { BasicTooltip } from '@nivo/tooltip'\nimport { BarDatum, BarTooltipProps } from './types'\n\nexport const BarTooltip = <D extends BarDatum>({ color, label, ...data }: BarTooltipProps<D>) => {\n    return <BasicTooltip id={label} value={data.formattedValue} enableChip={true} color={color} />\n}\n", "import { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport {\n    BarCommonProps,\n    BarDatum,\n    ComputedDatum,\n    BarSvgPropsWithDefaults,\n    BarCanvasPropsWithDefaults,\n} from './types'\nimport { BarItem } from './BarItem'\nimport { BarTooltip } from './BarTooltip'\nimport { renderBar } from './renderBar'\n\nexport const commonDefaultProps: Omit<BarCommonProps<BarDatum>, 'data' | 'theme'> = {\n    indexBy: 'id',\n    keys: ['value'],\n    groupMode: 'stacked' as const,\n    layout: 'vertical' as const,\n    valueScale: { type: 'linear', nice: true, round: false },\n    indexScale: { type: 'band', round: false },\n    padding: 0.1,\n    innerPadding: 0,\n    enableGridX: false,\n    enableGridY: true,\n    enableLabel: true,\n    label: 'formattedValue',\n    labelPosition: 'middle' as const,\n    labelOffset: 0,\n    labelSkipWidth: 0,\n    labelSkipHeight: 0,\n    labelTextColor: { theme: 'labels.text.fill' },\n    colorBy: 'id' as const,\n    colors: { scheme: 'nivo' } as OrdinalColorScaleConfig,\n    borderRadius: 0,\n    borderWidth: 0,\n    borderColor: { from: 'color' } as InheritedColorConfig<any>,\n    isInteractive: true,\n    tooltip: BarTooltip,\n    tooltipLabel: (datum: ComputedDatum<BarDatum>) => `${datum.id} - ${datum.indexValue}`,\n    legends: [],\n    initialHiddenIds: [],\n    annotations: [],\n    enableTotals: false,\n    totalsOffset: 10,\n}\n\nexport const svgDefaultProps: Omit<\n    BarSvgPropsWithDefaults<BarDatum>,\n    'data' | 'width' | 'height' | 'theme'\n> = {\n    ...commonDefaultProps,\n    layers: ['grid', 'axes', 'bars', 'totals', 'markers', 'legends', 'annotations'],\n    axisTop: null,\n    axisRight: null,\n    axisBottom: {},\n    axisLeft: {},\n    barComponent: BarItem,\n    defs: [],\n    fill: [],\n    markers: [],\n    animate: true,\n    animateOnMount: false,\n    motionConfig: 'default',\n    role: 'img',\n    isFocusable: false,\n}\n\nexport const canvasDefaultProps: Omit<\n    BarCanvasPropsWithDefaults<BarDatum>,\n    'data' | 'width' | 'height' | 'theme'\n> = {\n    ...commonDefaultProps,\n    layers: ['grid', 'axes', 'bars', 'totals', 'legends', 'annotations'],\n    axisTop: null,\n    axisRight: null,\n    axisBottom: {},\n    axisLeft: {},\n    renderBar,\n    pixelRatio: typeof window !== 'undefined' ? (window.devicePixelRatio ?? 1) : 1,\n}\n", "import { roundedRect } from '@nivo/canvas'\nimport { drawCanvasText } from '@nivo/text'\nimport { BarDatum, RenderBarProps } from './types'\n\nexport const renderBar = <D extends BarDatum>(\n    ctx: CanvasRenderingContext2D,\n    {\n        bar: { color, height, width, x, y },\n        borderColor,\n        borderRadius,\n        borderWidth,\n        label,\n        shouldRenderLabel,\n        labelStyle,\n        labelX,\n        labelY,\n        textAnchor,\n    }: RenderBarProps<D>\n) => {\n    ctx.fillStyle = color\n    if (borderWidth > 0) {\n        ctx.strokeStyle = borderColor\n        ctx.lineWidth = borderWidth\n    }\n\n    ctx.beginPath()\n    roundedRect(ctx, x, y, width, height, Math.min(borderRadius, height))\n    ctx.fill()\n\n    if (borderWidth > 0) {\n        ctx.stroke()\n    }\n\n    if (shouldRenderLabel) {\n        ctx.textBaseline = 'middle'\n        ctx.textAlign = textAnchor === 'middle' ? 'center' : textAnchor\n        drawCanvasText(ctx, labelStyle, label, x + labelX, y + labelY)\n    }\n}\n", "import { ScaleBandSpec, ScaleBand, computeScale } from '@nivo/scales'\nimport { commonDefaultProps } from '../defaults'\nimport { BarCommonProps, BarDatum } from '../types'\n\n/**\n * Generates indexed scale.\n */\nexport const getIndexScale = <D extends BarDatum>(\n    data: readonly D[],\n    getIndex: (datum: D) => string,\n    padding: number,\n    indexScale: ScaleBandSpec,\n    size: number,\n    axis: 'x' | 'y'\n) => {\n    return (\n        computeScale(\n            indexScale,\n            { all: data.map(getIndex), min: 0, max: 0 },\n            size,\n            axis\n        ) as ScaleBand<string>\n    ).padding(padding)\n}\n\n/**\n * This method ensures all the provided keys exist in the entire series.\n */\nexport const normalizeData = <D extends BarDatum>(data: readonly D[], keys: readonly string[]) =>\n    data.map(\n        item =>\n            ({\n                ...keys.reduce<Record<string, unknown>>((acc, key) => {\n                    acc[key] = null\n                    return acc\n                }, {}),\n                ...item,\n            }) as D\n    )\n\nexport const filterNullValues = <D extends BarDatum>(data: D) =>\n    Object.keys(data).reduce<Record<string, unknown>>((acc, key) => {\n        if (data[key]) {\n            acc[key] = data[key]\n        }\n        return acc\n    }, {}) as Exclude<D, null | undefined | false | '' | 0>\n\nexport const coerceValue = <T>(value: T) => [value, Number(value)] as const\n\nexport type BarLabelLayout = {\n    labelX: number\n    labelY: number\n    textAnchor: 'start' | 'middle' | 'end'\n}\n\n/**\n * Compute the label position and alignment based on a given position and offset.\n */\nexport function useComputeLabelLayout<D extends BarDatum>(\n    layout: BarCommonProps<D>['layout'] = commonDefaultProps.layout,\n    reverse: boolean,\n    labelPosition: BarCommonProps<D>['labelPosition'] = commonDefaultProps.labelPosition,\n    labelOffset: BarCommonProps<D>['labelOffset'] = commonDefaultProps.labelOffset\n): (width: number, height: number) => BarLabelLayout {\n    return (width: number, height: number) => {\n        // If the chart is reversed, we want to make sure the offset is also reversed\n        const computedLabelOffset = labelOffset * (reverse ? -1 : 1)\n\n        if (layout === 'horizontal') {\n            let x = width / 2\n            if (labelPosition === 'start') {\n                x = reverse ? width : 0\n            } else if (labelPosition === 'end') {\n                x = reverse ? 0 : width\n            }\n            return {\n                labelX: x + computedLabelOffset,\n                labelY: height / 2,\n                textAnchor: labelPosition === 'middle' ? 'middle' : reverse ? 'end' : 'start',\n            }\n        } else {\n            let y = height / 2\n            if (labelPosition === 'start') {\n                y = reverse ? 0 : height\n            } else if (labelPosition === 'end') {\n                y = reverse ? height : 0\n            }\n            return {\n                labelX: width / 2,\n                labelY: y - computedLabelOffset,\n                textAnchor: 'middle',\n            }\n        }\n    }\n}\n", "import { Margin } from '@nivo/core'\nimport { OrdinalColorScale } from '@nivo/colors'\nimport { Scale, ScaleBand, computeScale } from '@nivo/scales'\nimport { BarDatum, BarSvgProps, ComputedBarDatum, ComputedDatum } from '../types'\nimport { coerceValue, filterNullValues, getIndexScale, normalizeData } from './common'\n\ntype Params<D extends BarDatum, XScaleInput, YScaleInput> = {\n    data: readonly D[]\n    formatValue: (value: number) => string\n    getColor: OrdinalColorScale<ComputedDatum<D>>\n    getIndex: (datum: D) => string\n    getTooltipLabel: (datum: ComputedDatum<D>) => string\n    innerPadding: number\n    keys: string[]\n    xScale: XScaleInput extends string ? ScaleBand<XScaleInput> : Scale<XScaleInput, number>\n    yScale: YScaleInput extends string ? ScaleBand<YScaleInput> : Scale<YScaleInput, number>\n    margin: Margin\n}\n\nconst gt = (value: number, other: number) => value > other\nconst lt = (value: number, other: number) => value < other\n\nconst range = (start: number, end: number) =>\n    Array.from(' '.repeat(end - start), (_, index) => start + index)\n\nconst clampToZero = (value: number) => (gt(value, 0) ? 0 : value)\nconst zeroIfNotFinite = (value: number) => (isFinite(value) ? value : 0)\n\n/**\n * Generates x/y scales & bars for vertical grouped bar chart.\n */\nconst generateVerticalGroupedBars = <D extends BarDatum>(\n    {\n        data,\n        formatValue,\n        getColor,\n        getIndex,\n        getTooltipLabel,\n        innerPadding = 0,\n        keys,\n        xScale,\n        yScale,\n        margin,\n    }: Params<D, string, number>,\n    barWidth: number,\n    reverse: boolean,\n    yRef: number\n): ComputedBarDatum<D>[] => {\n    const compare = reverse ? lt : gt\n    const getY = (d: number) => (compare(d, 0) ? (yScale(d) ?? 0) : yRef)\n    const getHeight = (d: number, y: number) => (compare(d, 0) ? yRef - y : (yScale(d) ?? 0) - yRef)\n    const cleanedData = data.map(filterNullValues)\n\n    const bars: ComputedBarDatum<D>[] = []\n    keys.forEach((key, i) =>\n        range(0, xScale.domain().length).forEach(index => {\n            const [rawValue, value] = coerceValue(data[index][key])\n            const indexValue = getIndex(data[index])\n            const x = (xScale(indexValue) ?? 0) + barWidth * i + innerPadding * i\n            const y = getY(value)\n            const barHeight = getHeight(value, y)\n            const barData: ComputedDatum<D> = {\n                id: key,\n                value: rawValue === null ? rawValue : value,\n                formattedValue: formatValue(value),\n                hidden: false,\n                index,\n                indexValue,\n                data: cleanedData[index],\n            }\n\n            bars.push({\n                key: `${key}.${barData.indexValue}`,\n                index: bars.length,\n                data: barData,\n                x,\n                y,\n                absX: margin.left + x,\n                absY: margin.top + y,\n                width: barWidth,\n                height: barHeight,\n                color: getColor(barData),\n                label: getTooltipLabel(barData),\n            })\n        })\n    )\n\n    return bars\n}\n\n/**\n * Generates x/y scales & bars for horizontal grouped bar chart.\n */\nconst generateHorizontalGroupedBars = <D extends BarDatum>(\n    {\n        data,\n        formatValue,\n        getIndex,\n        getColor,\n        getTooltipLabel,\n        keys,\n        innerPadding = 0,\n        xScale,\n        yScale,\n        margin,\n    }: Params<D, number, string>,\n    barHeight: number,\n    reverse: boolean,\n    xRef: number\n): ComputedBarDatum<D>[] => {\n    const compare = reverse ? lt : gt\n    const getX = (d: number) => (compare(d, 0) ? xRef : (xScale(d) ?? 0))\n    const getWidth = (d: number, x: number) => (compare(d, 0) ? (xScale(d) ?? 0) - xRef : xRef - x)\n    const cleanedData = data.map(filterNullValues)\n\n    const bars: ComputedBarDatum<D>[] = []\n    keys.forEach((key, i) =>\n        range(0, yScale.domain().length).forEach(index => {\n            const [rawValue, value] = coerceValue(data[index][key])\n            const indexValue = getIndex(data[index])\n            const x = getX(value)\n            const y = (yScale(indexValue) ?? 0) + barHeight * i + innerPadding * i\n            const barWidth = getWidth(value, x)\n            const barData: ComputedDatum<D> = {\n                id: key,\n                value: rawValue === null ? rawValue : value,\n                formattedValue: formatValue(value),\n                hidden: false,\n                index,\n                indexValue,\n                data: cleanedData[index],\n            }\n\n            bars.push({\n                key: `${key}.${barData.indexValue}`,\n                index: bars.length,\n                data: barData,\n                x,\n                y,\n                absX: margin.left + x,\n                absY: margin.top + y,\n                width: barWidth,\n                height: barHeight,\n                color: getColor(barData),\n                label: getTooltipLabel(barData),\n            })\n        })\n    )\n\n    return bars\n}\n\n/**\n * Generates x/y scales & bars for grouped bar chart.\n */\nexport const generateGroupedBars = <D extends BarDatum>({\n    layout,\n    width,\n    height,\n    padding = 0,\n    innerPadding = 0,\n    valueScale,\n    indexScale: indexScaleConfig,\n    hiddenIds = [],\n    ...props\n}: Pick<\n    Required<BarSvgProps<D>>,\n    | 'data'\n    | 'height'\n    | 'valueScale'\n    | 'indexScale'\n    | 'innerPadding'\n    | 'keys'\n    | 'layout'\n    | 'padding'\n    | 'width'\n> & {\n    formatValue: (value: number) => string\n    getColor: OrdinalColorScale<ComputedDatum<D>>\n    getIndex: (datum: D) => string\n    getTooltipLabel: (datum: ComputedDatum<D>) => string\n    margin: Margin\n    hiddenIds?: readonly (string | number)[]\n}) => {\n    const keys = props.keys.filter(key => !hiddenIds.includes(key))\n    const data = normalizeData(props.data, keys)\n    const [axis, otherAxis, size] =\n        layout === 'vertical' ? (['y', 'x', width] as const) : (['x', 'y', height] as const)\n    const indexScale = getIndexScale(\n        data,\n        props.getIndex,\n        padding,\n        indexScaleConfig,\n        size,\n        otherAxis\n    )\n\n    const clampMin = valueScale.min === 'auto' ? clampToZero : (value: number) => value\n\n    const values = data\n        .reduce<number[]>((acc, entry) => [...acc, ...keys.map(k => entry[k] as number)], [])\n        .filter(Boolean)\n    const min = clampMin(Math.min(...values))\n    const max = zeroIfNotFinite(Math.max(...values))\n\n    const scale = computeScale(\n        valueScale,\n        { all: values, min, max },\n        axis === 'x' ? width : height,\n        axis\n    )\n\n    const [xScale, yScale] = layout === 'vertical' ? [indexScale, scale] : [scale, indexScale]\n\n    // As we use extra inner padding between the bars, we need to adjust the bandwidth.\n    const bandwidth = (indexScale.bandwidth() - innerPadding * (keys.length - 1)) / keys.length\n    const params = [\n        { ...props, data, keys, innerPadding, xScale, yScale } as Params<D, any, any>,\n        bandwidth,\n        valueScale.reverse ?? false,\n        scale(0) ?? 0,\n    ] as const\n\n    const bars: ComputedBarDatum<D>[] =\n        bandwidth > 0\n            ? layout === 'vertical'\n                ? generateVerticalGroupedBars(...params)\n                : generateHorizontalGroupedBars(...params)\n            : []\n\n    return { xScale, yScale, bars }\n}\n", "import { Margin } from '@nivo/core'\nimport { OrdinalColorScale } from '@nivo/colors'\nimport { Scale, ScaleBand, computeScale } from '@nivo/scales'\nimport { Series, SeriesPoint, stack, stackOffsetDiverging } from 'd3-shape'\nimport { BarDatum, BarSvgProps, ComputedBarDatum, ComputedDatum } from '../types'\nimport { coerceValue, filterNullValues, getIndexScale, normalizeData } from './common'\n\ntype StackDatum<D extends BarDatum> = SeriesPoint<D>\n\ntype Params<D extends BarDatum, XScaleInput, YScaleInput> = {\n    formatValue: (value: number) => string\n    getColor: OrdinalColorScale<ComputedDatum<D>>\n    getIndex: (datum: D) => string\n    getTooltipLabel: (datum: ComputedDatum<D>) => string\n    innerPadding: number\n    stackedData: Series<D, string>[]\n    xScale: XScaleInput extends string ? ScaleBand<XScaleInput> : Scale<XScaleInput, number>\n    yScale: YScaleInput extends string ? ScaleBand<YScaleInput> : Scale<YScaleInput, number>\n    margin: Margin\n}\n\nconst flattenDeep = <T>(arr: T[]): T =>\n    arr.some(Array.isArray) ? flattenDeep(([] as T[]).concat(...arr)) : (arr as unknown as T)\n\nconst filterZerosIfLog = (array: number[], type: string) =>\n    type === 'log' ? array.filter(num => num !== 0) : array\n\n/**\n * Generates x/y scales & bars for vertical stacked bar chart.\n */\nconst generateVerticalStackedBars = <D extends BarDatum>(\n    {\n        formatValue,\n        getColor,\n        getIndex,\n        getTooltipLabel,\n        innerPadding,\n        stackedData,\n        xScale,\n        yScale,\n        margin,\n    }: Params<D, string, number>,\n    barWidth: number,\n    reverse: boolean\n): ComputedBarDatum<D>[] => {\n    const getY = (d: StackDatum<D>) => yScale(d[reverse ? 0 : 1])\n    const getHeight = (d: StackDatum<D>, y: number) => (yScale(d[reverse ? 1 : 0]) ?? 0) - y\n\n    const bars: ComputedBarDatum<D>[] = []\n    stackedData.forEach(stackedDataItem =>\n        xScale.domain().forEach((index, i) => {\n            const d = stackedDataItem[i]\n            const x = xScale(getIndex(d.data)) ?? 0\n            const y = (getY(d) ?? 0) + innerPadding * 0.5\n            const barHeight = getHeight(d, y) - innerPadding\n            const [rawValue, value] = coerceValue(d.data[stackedDataItem.key])\n\n            const barData: ComputedDatum<D> = {\n                id: stackedDataItem.key,\n                value: rawValue === null ? rawValue : value,\n                formattedValue: formatValue(value),\n                hidden: false,\n                index: i,\n                indexValue: index,\n                data: filterNullValues(d.data),\n            }\n\n            bars.push({\n                key: `${stackedDataItem.key}.${index}`,\n                index: bars.length,\n                data: barData,\n                x,\n                y,\n                absX: margin.left + x,\n                absY: margin.top + y,\n                width: barWidth,\n                height: barHeight,\n                color: getColor(barData),\n                label: getTooltipLabel(barData),\n            })\n        })\n    )\n\n    return bars\n}\n\n/**\n * Generates x/y scales & bars for horizontal stacked bar chart.\n */\nconst generateHorizontalStackedBars = <D extends BarDatum>(\n    {\n        formatValue,\n        getColor,\n        getIndex,\n        getTooltipLabel,\n        innerPadding,\n        stackedData,\n        xScale,\n        yScale,\n        margin,\n    }: Params<D, number, string>,\n    barHeight: number,\n    reverse: boolean\n): ComputedBarDatum<D>[] => {\n    const getX = (d: StackDatum<D>) => xScale(d[reverse ? 1 : 0])\n    const getWidth = (d: StackDatum<D>, x: number) => (xScale(d[reverse ? 0 : 1]) ?? 0) - x\n\n    const bars: ComputedBarDatum<D>[] = []\n    stackedData.forEach(stackedDataItem =>\n        yScale.domain().forEach((index, i) => {\n            const d = stackedDataItem[i]\n            const y = yScale(getIndex(d.data)) ?? 0\n            const x = (getX(d) ?? 0) + innerPadding * 0.5\n            const barWidth = getWidth(d, x) - innerPadding\n            const [rawValue, value] = coerceValue(d.data[stackedDataItem.key])\n\n            const barData: ComputedDatum<D> = {\n                id: stackedDataItem.key,\n                value: rawValue === null ? rawValue : value,\n                formattedValue: formatValue(value),\n                hidden: false,\n                index: i,\n                indexValue: index,\n                data: filterNullValues(d.data),\n            }\n\n            bars.push({\n                key: `${stackedDataItem.key}.${index}`,\n                index: bars.length,\n                data: barData,\n                x,\n                y,\n                absX: margin.left + x,\n                absY: margin.top + y,\n                width: barWidth,\n                height: barHeight,\n                color: getColor(barData),\n                label: getTooltipLabel(barData),\n            })\n        })\n    )\n\n    return bars\n}\n\n/**\n * Generates x/y scales & bars for stacked bar chart.\n */\nexport const generateStackedBars = <RawDatum extends BarDatum>({\n    data,\n    layout,\n    width,\n    height,\n    padding = 0,\n    valueScale,\n    indexScale: indexScaleConfig,\n    hiddenIds = [],\n    ...props\n}: Pick<\n    Required<BarSvgProps<RawDatum>>,\n    | 'data'\n    | 'height'\n    | 'valueScale'\n    | 'indexScale'\n    | 'innerPadding'\n    | 'keys'\n    | 'layout'\n    | 'padding'\n    | 'width'\n> & {\n    formatValue: (value: number) => string\n    getColor: OrdinalColorScale<ComputedDatum<RawDatum>>\n    getIndex: (datum: RawDatum) => string\n    getTooltipLabel: (datum: ComputedDatum<RawDatum>) => string\n    margin: Margin\n    hiddenIds?: readonly (string | number)[]\n}) => {\n    const keys = props.keys.filter(key => !hiddenIds.includes(key))\n    const stackedData = stack<RawDatum, string>().keys(keys).offset(stackOffsetDiverging)(\n        normalizeData(data, keys)\n    )\n\n    const [axis, otherAxis, size] =\n        layout === 'vertical' ? (['y', 'x', width] as const) : (['x', 'y', height] as const)\n    const indexScale = getIndexScale(\n        data,\n        props.getIndex,\n        padding,\n        indexScaleConfig,\n        size,\n        otherAxis\n    )\n\n    const values = filterZerosIfLog(\n        flattenDeep(stackedData as unknown as number[][]),\n        valueScale.type\n    )\n    const min = Math.min(...values)\n    const max = Math.max(...values)\n\n    const scale = computeScale(\n        valueScale,\n        { all: values, min, max },\n        axis === 'x' ? width : height,\n        axis\n    )\n\n    const [xScale, yScale] = layout === 'vertical' ? [indexScale, scale] : [scale, indexScale]\n\n    const innerPadding = props.innerPadding > 0 ? props.innerPadding : 0\n    const bandwidth = indexScale.bandwidth()\n    const params = [\n        { ...props, innerPadding, stackedData, xScale, yScale } as Params<RawDatum, any, any>,\n        bandwidth,\n        valueScale.reverse ?? false,\n    ] as const\n\n    const bars: ComputedBarDatum<RawDatum>[] =\n        bandwidth > 0\n            ? layout === 'vertical'\n                ? generateVerticalStackedBars(...params)\n                : generateHorizontalStackedBars(...params)\n            : []\n\n    return { xScale, yScale, bars }\n}\n", "import {\n    BarDatum,\n    BarLegendProps,\n    BarSvgProps,\n    BarsWithHidden,\n    LegendData,\n    LegendLabelDatum,\n} from '../types'\nimport { getPropertyAccessor } from '@nivo/core'\nimport uniqBy from 'lodash/uniqBy.js'\n\nexport const getLegendDataForKeys = <RawDatum extends BarDatum>(\n    bars: BarsWithHidden<RawDatum>,\n    layout: NonNullable<BarSvgProps<RawDatum>['layout']>,\n    direction: BarLegendProps['direction'],\n    groupMode: NonNullable<BarSvgProps<RawDatum>['groupMode']>,\n    reverse: boolean,\n    getLegendLabel: (datum: LegendLabelDatum<RawDatum>) => string\n): LegendData[] => {\n    const data = uniqBy(\n        bars.map(bar => ({\n            id: bar.data.id,\n            label: getLegendLabel(bar.data),\n            hidden: bar.data.hidden,\n            color: bar.color ?? '#000',\n        })),\n        ({ id }) => id\n    )\n\n    if (\n        (layout === 'vertical' &&\n            groupMode === 'stacked' &&\n            direction === 'column' &&\n            reverse !== true) ||\n        (layout === 'horizontal' && groupMode === 'stacked' && reverse === true)\n    ) {\n        data.reverse()\n    }\n\n    return data\n}\n\nexport const getLegendDataForIndexes = <RawDatum extends BarDatum>(\n    bars: BarsWithHidden<RawDatum>,\n    layout: NonNullable<BarSvgProps<RawDatum>['layout']>,\n    getLegendLabel: (datum: LegendLabelDatum<RawDatum>) => string\n): LegendData[] => {\n    const data = uniqBy(\n        bars.map(bar => ({\n            id: bar.data.indexValue ?? '',\n            label: getLegendLabel(bar.data),\n            hidden: bar.data.hidden,\n            color: bar.color ?? '#000',\n        })),\n        ({ id }) => id\n    )\n\n    if (layout === 'horizontal') {\n        data.reverse()\n    }\n\n    return data\n}\n\nexport const getLegendData = <RawDatum extends BarDatum>({\n    bars,\n    direction,\n    from,\n    groupMode,\n    layout,\n    legendLabel,\n    reverse,\n}: Pick<Required<BarSvgProps<RawDatum>>, 'layout' | 'groupMode'> & {\n    bars: BarsWithHidden<RawDatum>\n    direction: BarLegendProps['direction']\n    from: BarLegendProps['dataFrom']\n    legendLabel: BarSvgProps<RawDatum>['legendLabel']\n    reverse: boolean\n}) => {\n    const getLegendLabel = getPropertyAccessor(\n        legendLabel ?? (from === 'indexes' ? 'indexValue' : 'id')\n    )\n\n    if (from === 'indexes') {\n        return getLegendDataForIndexes(bars, layout, getLegendLabel)\n    }\n\n    return getLegendDataForKeys(bars, layout, direction, groupMode, reverse, getLegendLabel)\n}\n", "import { AnyScale, ScaleBand } from '@nivo/scales'\nimport { commonDefaultProps } from '../defaults'\nimport { BarCommonProps, BarDatum, ComputedBarDatum } from '../types'\n\nexport interface BarTotalsData {\n    key: string\n    x: number\n    y: number\n    value: number\n    formattedValue: string\n    animationOffset: number\n}\n\nexport const computeBarTotals = <D extends BarDatum>(\n    bars: ComputedBarDatum<D>[],\n    xScale: ScaleBand<string> | AnyScale,\n    yScale: ScaleBand<string> | AnyScale,\n    layout: BarCommonProps<D>['layout'] = commonDefaultProps.layout,\n    groupMode: BarCommonProps<D>['groupMode'] = commonDefaultProps.groupMode,\n    totalsOffset: number,\n    formatValue: (value: number) => string\n) => {\n    const totals = [] as BarTotalsData[]\n\n    if (bars.length === 0) return totals\n\n    const totalsByIndex = new Map<string | number, number>()\n\n    const barWidth = bars[0].width\n    const barHeight = bars[0].height\n\n    if (groupMode === 'stacked') {\n        const totalsPositivesByIndex = new Map<string | number, number>()\n\n        bars.forEach(bar => {\n            const { indexValue, value } = bar.data\n            updateTotalsByIndex(totalsByIndex, indexValue, Number(value))\n            updateTotalsPositivesByIndex(totalsPositivesByIndex, indexValue, Number(value))\n        })\n\n        totalsPositivesByIndex.forEach((totalsPositive, indexValue) => {\n            const indexTotal = totalsByIndex.get(indexValue) || 0\n\n            let xPosition: number\n            let yPosition: number\n            let animationOffset: number\n\n            if (layout === 'vertical') {\n                xPosition = xScale(indexValue)\n                yPosition = yScale(totalsPositive)\n                animationOffset = yScale(totalsPositive / 2)\n            } else {\n                xPosition = xScale(totalsPositive)\n                yPosition = yScale(indexValue)\n                animationOffset = xScale(totalsPositive / 2)\n            }\n\n            xPosition += layout === 'vertical' ? barWidth / 2 : totalsOffset\n            yPosition += layout === 'vertical' ? -totalsOffset : barHeight / 2\n\n            totals.push({\n                key: 'total_' + indexValue,\n                x: xPosition,\n                y: yPosition,\n                value: indexTotal,\n                formattedValue: formatValue(indexTotal),\n                animationOffset,\n            })\n        })\n    } else if (groupMode === 'grouped') {\n        const greatestValueByIndex = new Map<string | number, number>()\n        const numberOfBarsByIndex = new Map()\n\n        bars.forEach(bar => {\n            const { indexValue, value } = bar.data\n            updateTotalsByIndex(totalsByIndex, indexValue, Number(value))\n            updateGreatestValueByIndex(greatestValueByIndex, indexValue, Number(value))\n            updateNumberOfBarsByIndex(numberOfBarsByIndex, indexValue)\n        })\n\n        greatestValueByIndex.forEach((greatestValue, indexValue) => {\n            const indexTotal = totalsByIndex.get(indexValue) || 0\n            const numberOfBars = numberOfBarsByIndex.get(indexValue)\n\n            let xPosition: number\n            let yPosition: number\n            let animationOffset: number\n\n            if (layout === 'vertical') {\n                xPosition = xScale(indexValue)\n                yPosition = yScale(greatestValue)\n                animationOffset = yScale(greatestValue / 2)\n            } else {\n                xPosition = xScale(greatestValue)\n                yPosition = yScale(indexValue)\n                animationOffset = xScale(greatestValue / 2)\n            }\n\n            const indexBarsWidth = numberOfBars * barWidth\n            const indexBarsHeight = numberOfBars * barHeight\n\n            xPosition += layout === 'vertical' ? indexBarsWidth / 2 : totalsOffset\n            yPosition += layout === 'vertical' ? -totalsOffset : indexBarsHeight / 2\n\n            totals.push({\n                key: 'total_' + indexValue,\n                x: xPosition,\n                y: yPosition,\n                value: indexTotal,\n                formattedValue: formatValue(indexTotal),\n                animationOffset,\n            })\n        })\n    }\n    return totals\n}\n\n// this function is used to compute the total value for the indexes. The total value is later rendered on the chart\nexport const updateTotalsByIndex = (\n    totalsByIndex: Map<string | number, number>,\n    indexValue: string | number,\n    value: number\n) => {\n    const currentIndexValue = totalsByIndex.get(indexValue) || 0\n    totalsByIndex.set(indexValue, currentIndexValue + value)\n}\n\n// this function is used to compute only the positive values of the indexes. Useful to position the text right above the last stacked bar. It prevents overlapping in case of negative values\nexport const updateTotalsPositivesByIndex = (\n    totalsPositivesByIndex: Map<string | number, number>,\n    indexValue: string | number,\n    value: number\n) => {\n    const currentIndexValue = totalsPositivesByIndex.get(indexValue) || 0\n    totalsPositivesByIndex.set(indexValue, currentIndexValue + (value > 0 ? value : 0))\n}\n\n// this function is used to keep track of the highest value for the indexes. Useful to position the text above the longest grouped bar\nexport const updateGreatestValueByIndex = (\n    greatestValueByIndex: Map<string | number, number>,\n    indexValue: string | number,\n    value: number\n) => {\n    const currentGreatestValue = greatestValueByIndex.get(indexValue) || 0\n    greatestValueByIndex.set(indexValue, Math.max(currentGreatestValue, Number(value)))\n}\n\n// this function is used to save the number of bars for the indexes. Useful to position the text in the middle of the grouped bars\nexport const updateNumberOfBarsByIndex = (\n    numberOfBarsByIndex: Map<string | number, number>,\n    indexValue: string | number\n) => {\n    const currentNumberOfBars = numberOfBarsByIndex.get(indexValue) || 0\n    numberOfBarsByIndex.set(indexValue, currentNumberOfBars + 1)\n}\n", "import { useCallback, useMemo, useState } from 'react'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport { usePropertyAccessor, useValueFormatter, Margin } from '@nivo/core'\nimport { useTheme } from '@nivo/theming'\nimport {\n    DataProps,\n    BarCommonProps,\n    BarDatum,\n    ComputedBarDatumWithValue,\n    LegendData,\n    BarLegendProps,\n} from './types'\nimport { commonDefaultProps } from './defaults'\nimport { generateGroupedBars, generateStackedBars, getLegendData } from './compute'\nimport { computeBarTotals } from './compute/totals'\n\nexport const useBar = <D extends BarDatum>({\n    indexBy = commonDefaultProps.indexBy,\n    keys = commonDefaultProps.keys,\n    label = commonDefaultProps.label,\n    tooltipLabel = commonDefaultProps.tooltipLabel,\n    valueFormat,\n    colors = commonDefaultProps.colors,\n    colorBy = commonDefaultProps.colorBy,\n    borderColor = commonDefaultProps.borderColor,\n    labelTextColor = commonDefaultProps.labelTextColor,\n    groupMode = commonDefaultProps.groupMode,\n    layout = commonDefaultProps.layout,\n    data,\n    margin,\n    width,\n    height,\n    padding = commonDefaultProps.padding,\n    innerPadding = commonDefaultProps.innerPadding,\n    valueScale = commonDefaultProps.valueScale,\n    indexScale = commonDefaultProps.indexScale,\n    initialHiddenIds = commonDefaultProps.initialHiddenIds,\n    enableLabel = commonDefaultProps.enableLabel,\n    labelSkipWidth = commonDefaultProps.labelSkipWidth,\n    labelSkipHeight = commonDefaultProps.labelSkipHeight,\n    legends = commonDefaultProps.legends,\n    legendLabel,\n    totalsOffset = commonDefaultProps.totalsOffset,\n}: Partial<\n    Pick<\n        BarCommonProps<D>,\n        | 'indexBy'\n        | 'keys'\n        | 'label'\n        | 'tooltipLabel'\n        | 'valueFormat'\n        | 'colors'\n        | 'colorBy'\n        | 'borderColor'\n        | 'labelTextColor'\n        | 'groupMode'\n        | 'layout'\n        | 'padding'\n        | 'innerPadding'\n        | 'valueScale'\n        | 'indexScale'\n        | 'initialHiddenIds'\n        | 'enableLabel'\n        | 'labelSkipWidth'\n        | 'labelSkipHeight'\n        | 'legends'\n        | 'legendLabel'\n        | 'totalsOffset'\n    >\n> & {\n    width: number\n    height: number\n    margin: Margin\n    data: DataProps<D>['data']\n}) => {\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n    const toggleSerie = useCallback((id: string | number) => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const getIndex = usePropertyAccessor(indexBy)\n    const getLabel = usePropertyAccessor(label)\n    const getTooltipLabel = usePropertyAccessor(tooltipLabel)\n    const formatValue = useValueFormatter(valueFormat)\n\n    const theme = useTheme()\n    const getColor = useOrdinalColorScale(colors, colorBy)\n    const getBorderColor = useInheritedColor<ComputedBarDatumWithValue<D>>(borderColor, theme)\n    const getLabelColor = useInheritedColor<ComputedBarDatumWithValue<D>>(labelTextColor, theme)\n\n    const generateBars = groupMode === 'grouped' ? generateGroupedBars : generateStackedBars\n    const { bars, xScale, yScale } = generateBars({\n        layout,\n        data,\n        getIndex,\n        keys,\n        width,\n        height,\n        getColor,\n        padding,\n        innerPadding,\n        valueScale,\n        indexScale,\n        hiddenIds,\n        formatValue,\n        getTooltipLabel,\n        margin,\n    })\n\n    const barsWithValue = useMemo(\n        () =>\n            bars\n                .filter((bar): bar is ComputedBarDatumWithValue<D> => bar.data.value !== null)\n                .map((bar, index) => ({\n                    ...bar,\n                    index,\n                })),\n        [bars]\n    )\n\n    const shouldRenderBarLabel = useCallback(\n        ({ width, height }: { height: number; width: number }) => {\n            if (!enableLabel) return false\n            if (labelSkipWidth > 0 && width < labelSkipWidth) return false\n            if (labelSkipHeight > 0 && height < labelSkipHeight) return false\n            return true\n        },\n        [enableLabel, labelSkipWidth, labelSkipHeight]\n    )\n\n    const legendData = useMemo(\n        () =>\n            keys.map(key => {\n                const bar = bars.find(bar => bar.data.id === key)\n\n                return { ...bar, data: { id: key, ...bar?.data, hidden: hiddenIds.includes(key) } }\n            }),\n        [hiddenIds, keys, bars]\n    )\n\n    const reverse = valueScale.reverse ?? false\n\n    const legendsWithData: [BarLegendProps, LegendData[]][] = useMemo(\n        () =>\n            legends.map(legend => {\n                const data = getLegendData({\n                    bars: legend.dataFrom === 'keys' ? legendData : bars,\n                    direction: legend.direction,\n                    from: legend.dataFrom,\n                    groupMode,\n                    layout,\n                    legendLabel,\n                    reverse,\n                })\n\n                return [legend, data]\n            }),\n        [legends, legendData, bars, groupMode, layout, legendLabel, reverse]\n    )\n\n    const barTotals = useMemo(\n        () => computeBarTotals(bars, xScale, yScale, layout, groupMode, totalsOffset, formatValue),\n        [bars, xScale, yScale, layout, groupMode, totalsOffset, formatValue]\n    )\n\n    return {\n        bars,\n        barsWithValue,\n        xScale,\n        yScale,\n        getIndex,\n        getLabel,\n        getTooltipLabel,\n        formatValue,\n        getColor,\n        getBorderColor,\n        getLabelColor,\n        shouldRenderBarLabel,\n        hiddenIds,\n        toggleSerie,\n        legendsWithData,\n        barTotals,\n    }\n}\n", "import { useTheme } from '@nivo/theming'\nimport { AnimationConfig, animated, useTransition } from '@react-spring/web'\nimport { BarCommonProps, BarDatum } from './types'\nimport { svgDefaultProps } from './defaults'\nimport { BarTotalsData } from './compute/totals'\n\ninterface Props<RawDatum extends BarDatum> {\n    data: BarTotalsData[]\n    springConfig: Partial<AnimationConfig>\n    animate: boolean\n    layout?: BarCommonProps<RawDatum>['layout']\n}\n\nexport const BarTotals = <RawDatum extends BarDatum>({\n    data,\n    springConfig,\n    animate,\n    layout = svgDefaultProps.layout,\n}: Props<RawDatum>) => {\n    const theme = useTheme()\n    const totalsTransition = useTransition<\n        BarTotalsData,\n        {\n            x: number\n            y: number\n            labelOpacity: number\n        }\n    >(data, {\n        keys: barTotal => barTotal.key,\n        from: barTotal => ({\n            x: layout === 'vertical' ? barTotal.x : barTotal.animationOffset,\n            y: layout === 'vertical' ? barTotal.animationOffset : barTotal.y,\n            labelOpacity: 0,\n        }),\n        enter: barTotal => ({\n            x: barTotal.x,\n            y: barTotal.y,\n            labelOpacity: 1,\n        }),\n        update: barTotal => ({\n            x: barTotal.x,\n            y: barTotal.y,\n            labelOpacity: 1,\n        }),\n        leave: barTotal => ({\n            x: layout === 'vertical' ? barTotal.x : barTotal.animationOffset,\n            y: layout === 'vertical' ? barTotal.animationOffset : barTotal.y,\n            labelOpacity: 0,\n        }),\n        config: springConfig,\n        immediate: !animate,\n        initial: animate ? undefined : null,\n    })\n\n    return totalsTransition((style, barTotal) => (\n        <animated.text\n            key={barTotal.key}\n            x={style.x}\n            y={style.y}\n            fillOpacity={style.labelOpacity}\n            style={{\n                ...theme.labels.text,\n                pointerEvents: 'none',\n            }}\n            fontWeight=\"bold\"\n            fontSize={theme.labels.text.fontSize}\n            fontFamily={theme.labels.text.fontFamily}\n            textAnchor={layout === 'vertical' ? 'middle' : 'start'}\n            alignmentBaseline={layout === 'vertical' ? 'alphabetic' : 'middle'}\n        >\n            {barTotal.formattedValue}\n        </animated.text>\n    ))\n}\n", "import { forwardRef, Ref, ReactElement } from 'react'\nimport { Axes, Grid } from '@nivo/axes'\nimport {\n    CartesianMarkers,\n    Container,\n    SvgWrapper,\n    // @ts-expect-error no types\n    bindDefs,\n    useDimensions,\n    useMotionConfig,\n    WithChartRef,\n} from '@nivo/core'\nimport { useTransition } from '@react-spring/web'\nimport { Fragment, ReactNode, createElement, useMemo } from 'react'\nimport { BarAnnotations } from './BarAnnotations'\nimport { BarLegends } from './BarLegends'\nimport { useBar } from './hooks'\nimport { svgDefaultProps } from './defaults'\nimport {\n    BarComponent,\n    BarCustomLayerProps,\n    BarDatum,\n    BarItemProps,\n    BarLayerId,\n    BarSvgProps,\n    BarTooltipComponent,\n    ComputedBarDatumWithValue,\n} from './types'\nimport { BarTotals } from './BarTotals'\nimport { useComputeLabelLayout } from './compute/common'\n\ntype InnerBarProps<D extends BarDatum> = Omit<\n    BarSvgProps<D>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerBar = <D extends BarDatum>({\n    data,\n    indexBy,\n    keys,\n    margin: partialMargin,\n    width,\n    height,\n    groupMode,\n    layout,\n    valueScale,\n    indexScale,\n    padding,\n    innerPadding,\n    axisTop,\n    axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n    gridXValues,\n    gridYValues,\n    layers = svgDefaultProps.layers as BarLayerId[],\n    barComponent = svgDefaultProps.barComponent as unknown as BarComponent<D>,\n    enableLabel = svgDefaultProps.enableLabel,\n    label,\n    labelSkipWidth = svgDefaultProps.labelSkipWidth,\n    labelSkipHeight = svgDefaultProps.labelSkipHeight,\n    labelTextColor,\n    labelPosition = svgDefaultProps.labelPosition,\n    labelOffset = svgDefaultProps.labelOffset,\n    markers = svgDefaultProps.markers,\n    colorBy,\n    colors,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n    borderRadius = svgDefaultProps.borderRadius,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor,\n    annotations = svgDefaultProps.annotations,\n    legendLabel,\n    tooltipLabel,\n    valueFormat,\n    isInteractive = svgDefaultProps.isInteractive,\n    tooltip = svgDefaultProps.tooltip as BarTooltipComponent<D>,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    legends,\n    role = svgDefaultProps.role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    isFocusable = svgDefaultProps.isFocusable,\n    barAriaLabel,\n    barAriaLabelledBy,\n    barAriaDescribedBy,\n    barAriaHidden,\n    barAriaDisabled,\n    initialHiddenIds,\n    enableTotals = svgDefaultProps.enableTotals,\n    totalsOffset = svgDefaultProps.totalsOffset,\n    forwardedRef,\n}: InnerBarProps<D> & {\n    forwardedRef: Ref<SVGSVGElement>\n}) => {\n    const { animate, config: springConfig } = useMotionConfig()\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        bars,\n        barsWithValue,\n        xScale,\n        yScale,\n        getLabel,\n        getTooltipLabel,\n        getBorderColor,\n        getLabelColor,\n        shouldRenderBarLabel,\n        toggleSerie,\n        legendsWithData,\n        barTotals,\n        getColor,\n    } = useBar<D>({\n        indexBy,\n        label,\n        tooltipLabel,\n        valueFormat,\n        colors,\n        colorBy,\n        borderColor,\n        labelTextColor,\n        groupMode,\n        layout,\n        data,\n        keys,\n        margin,\n        width: innerWidth,\n        height: innerHeight,\n        padding,\n        innerPadding,\n        valueScale,\n        indexScale,\n        enableLabel,\n        labelSkipWidth,\n        labelSkipHeight,\n        legends,\n        legendLabel,\n        initialHiddenIds,\n        totalsOffset,\n    })\n\n    const computeLabelLayout = useComputeLabelLayout(\n        layout,\n        valueScale?.reverse ?? false,\n        labelPosition,\n        labelOffset\n    )\n\n    const transition = useTransition<\n        ComputedBarDatumWithValue<D>,\n        {\n            borderColor: string\n            color: string\n            height: number\n            labelColor: string\n            labelOpacity: number\n            labelX: number\n            labelY: number\n            opacity: number\n            transform: string\n            width: number\n            textAnchor: BarItemProps<D>['style']['textAnchor']\n        }\n    >(barsWithValue, {\n        keys: bar => bar.key,\n        from: bar => ({\n            borderColor: getBorderColor(bar) as string,\n            color: bar.color,\n            height: 0,\n            labelColor: getLabelColor(bar) as string,\n            labelOpacity: 0,\n            ...computeLabelLayout(bar.width, bar.height),\n            transform: `translate(${bar.x}, ${bar.y + bar.height})`,\n            width: bar.width,\n            ...(layout === 'vertical'\n                ? {}\n                : {\n                      height: bar.height,\n                      transform: `translate(${bar.x}, ${bar.y})`,\n                      width: 0,\n                  }),\n        }),\n        enter: bar => ({\n            borderColor: getBorderColor(bar) as string,\n            color: bar.color,\n            height: bar.height,\n            labelColor: getLabelColor(bar) as string,\n            labelOpacity: 1,\n            ...computeLabelLayout(bar.width, bar.height),\n            transform: `translate(${bar.x}, ${bar.y})`,\n            width: bar.width,\n        }),\n        update: bar => ({\n            borderColor: getBorderColor(bar) as string,\n            color: bar.color,\n            height: bar.height,\n            labelColor: getLabelColor(bar) as string,\n            labelOpacity: 1,\n            ...computeLabelLayout(bar.width, bar.height),\n            transform: `translate(${bar.x}, ${bar.y})`,\n            width: bar.width,\n        }),\n        leave: bar => ({\n            borderColor: getBorderColor(bar) as string,\n            color: bar.color,\n            height: 0,\n            labelColor: getLabelColor(bar) as string,\n            labelOpacity: 0,\n            ...computeLabelLayout(bar.width, bar.height),\n            labelY: 0,\n            transform: `translate(${bar.x}, ${bar.y + bar.height})`,\n            width: bar.width,\n            ...(layout === 'vertical'\n                ? {}\n                : {\n                      ...computeLabelLayout(bar.width, bar.height),\n                      labelX: 0,\n                      height: bar.height,\n                      transform: `translate(${bar.x}, ${bar.y})`,\n                      width: 0,\n                  }),\n        }),\n        config: springConfig,\n        immediate: !animate,\n        initial: animate ? undefined : null,\n    })\n\n    const commonProps = useMemo(\n        () => ({\n            borderRadius,\n            borderWidth,\n            enableLabel,\n            isInteractive,\n            labelSkipWidth,\n            labelSkipHeight,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            getTooltipLabel,\n            tooltip,\n            isFocusable,\n            ariaLabel: barAriaLabel,\n            ariaLabelledBy: barAriaLabelledBy,\n            ariaDescribedBy: barAriaDescribedBy,\n            ariaHidden: barAriaHidden,\n            ariaDisabled: barAriaDisabled,\n        }),\n        [\n            borderRadius,\n            borderWidth,\n            enableLabel,\n            getTooltipLabel,\n            isInteractive,\n            labelSkipHeight,\n            labelSkipWidth,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            tooltip,\n            isFocusable,\n            barAriaLabel,\n            barAriaLabelledBy,\n            barAriaDescribedBy,\n            barAriaHidden,\n            barAriaDisabled,\n        ]\n    )\n\n    const boundDefs = bindDefs(defs, bars, fill, {\n        dataKey: 'data',\n        targetKey: 'data.fill',\n    })\n\n    const layerById: Record<BarLayerId, ReactNode> = {\n        annotations: null,\n        axes: null,\n        bars: null,\n        grid: null,\n        legends: null,\n        markers: null,\n        totals: null,\n    }\n\n    if (layers.includes('annotations')) {\n        layerById.annotations = (\n            <BarAnnotations key=\"annotations\" bars={bars} annotations={annotations} />\n        )\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (layers.includes('bars')) {\n        layerById.bars = (\n            <Fragment key=\"bars\">\n                {transition((style, bar) =>\n                    createElement(barComponent, {\n                        ...commonProps,\n                        bar,\n                        style,\n                        shouldRenderLabel: shouldRenderBarLabel(bar),\n                        label: getLabel(bar.data),\n                    })\n                )}\n            </Fragment>\n        )\n    }\n\n    if (layers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <BarLegends\n                key=\"legends\"\n                width={innerWidth}\n                height={innerHeight}\n                legends={legendsWithData}\n                toggleSerie={toggleSerie}\n            />\n        )\n    }\n\n    if (layers.includes('markers')) {\n        layerById.markers = (\n            <CartesianMarkers<number | string, number>\n                key=\"markers\"\n                markers={markers as any[]}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={xScale as (v: number | string) => number}\n                yScale={yScale as (v: number) => number}\n            />\n        )\n    }\n\n    if (layers.includes('totals') && enableTotals) {\n        layerById.totals = (\n            <BarTotals\n                key=\"totals\"\n                data={barTotals}\n                springConfig={springConfig}\n                animate={animate}\n                layout={layout}\n            />\n        )\n    }\n\n    const layerContext: BarCustomLayerProps<D> = {\n        ...commonProps,\n        margin,\n        width,\n        height,\n        innerWidth,\n        innerHeight,\n        bars,\n        legendData: legendsWithData,\n        enableLabel,\n        xScale,\n        yScale,\n        tooltip,\n        getTooltipLabel,\n        onClick,\n        onMouseEnter,\n        onMouseLeave,\n        getColor,\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n            isFocusable={isFocusable}\n            ref={forwardedRef}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Bar = forwardRef(\n    <D extends BarDatum>(\n        {\n            isInteractive = svgDefaultProps.isInteractive,\n            animate = svgDefaultProps.animate,\n            motionConfig = svgDefaultProps.motionConfig,\n            theme,\n            renderWrapper,\n            ...props\n        }: BarSvgProps<D>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <Container\n            animate={animate}\n            isInteractive={isInteractive}\n            motionConfig={motionConfig}\n            renderWrapper={renderWrapper}\n            theme={theme}\n        >\n            <InnerBar<D> {...props} isInteractive={isInteractive} forwardedRef={ref} />\n        </Container>\n    )\n) as <D extends BarDatum>(props: WithChartRef<BarSvgProps<D>, SVGSVGElement>) => ReactElement\n", "import {\n    createElement,\n    forwardRef,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n    ReactElement,\n    Ref,\n} from 'react'\nimport {\n    Container,\n    Margin,\n    getRelativeCursor,\n    isCursorInRect,\n    useDimensions,\n    useValueFormatter,\n    WithChartRef,\n    mergeRefs,\n} from '@nivo/core'\nimport { Theme, useTheme } from '@nivo/theming'\nimport { setCanvasFont, drawCanvasText } from '@nivo/text'\nimport { canvasDefaultProps } from './defaults'\nimport {\n    renderAnnotationsToCanvas,\n    useAnnotations,\n    useComputedAnnotations,\n} from '@nivo/annotations'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport {\n    BarCanvasCustomLayerProps,\n    BarCanvasLayer,\n    BarCanvasProps,\n    BarCanvasRenderer,\n    BarCommonProps,\n    BarDatum,\n    BarTooltipComponent,\n    ComputedBarDatum,\n} from './types'\nimport { useBar } from './hooks'\nimport { BarTotalsData } from './compute/totals'\nimport { useComputeLabelLayout } from './compute/common'\n\nconst findBarUnderCursor = <D extends BarDatum>(\n    nodes: ComputedBarDatum<D>[],\n    margin: Margin,\n    x: number,\n    y: number\n) =>\n    nodes.find(node =>\n        isCursorInRect(node.x + margin.left, node.y + margin.top, node.width, node.height, x, y)\n    )\n\nconst isNumber = (value: unknown): value is number => typeof value === 'number'\n\nfunction renderTotalsToCanvas<D extends BarDatum>(\n    ctx: CanvasRenderingContext2D,\n    barTotals: BarTotalsData[],\n    theme: Theme,\n    layout: BarCommonProps<D>['layout'] = canvasDefaultProps.layout\n) {\n    setCanvasFont(ctx, theme.labels.text)\n    ctx.textBaseline = layout === 'vertical' ? 'alphabetic' : 'middle'\n    ctx.textAlign = layout === 'vertical' ? 'center' : 'start'\n\n    barTotals.forEach(barTotal => {\n        drawCanvasText(ctx, theme.labels.text, barTotal.formattedValue, barTotal.x, barTotal.y)\n    })\n}\n\ntype InnerBarCanvasProps<RawDatum extends BarDatum> = Omit<\n    BarCanvasProps<RawDatum>,\n    'renderWrapper' | 'theme'\n> & {\n    forwardedRef: Ref<HTMLCanvasElement>\n}\n\nconst InnerBarCanvas = <D extends BarDatum>({\n    data,\n    indexBy,\n    keys,\n    margin: partialMargin,\n    width,\n    height,\n    groupMode,\n    layout,\n    valueScale,\n    indexScale,\n    padding,\n    innerPadding,\n    axisTop,\n    axisRight,\n    axisBottom = canvasDefaultProps.axisBottom,\n    axisLeft = canvasDefaultProps.axisLeft,\n    enableGridX = canvasDefaultProps.enableGridX,\n    enableGridY = canvasDefaultProps.enableGridY,\n    gridXValues,\n    gridYValues,\n    labelPosition = canvasDefaultProps.labelPosition,\n    labelOffset = canvasDefaultProps.labelOffset,\n    layers = canvasDefaultProps.layers as BarCanvasLayer<D>[],\n    renderBar = canvasDefaultProps.renderBar as unknown as BarCanvasRenderer<D>,\n    enableLabel = canvasDefaultProps.enableLabel,\n    label,\n    labelSkipWidth = canvasDefaultProps.labelSkipWidth,\n    labelSkipHeight = canvasDefaultProps.labelSkipHeight,\n    labelTextColor,\n    colorBy,\n    colors,\n    borderRadius = canvasDefaultProps.borderRadius,\n    borderWidth = canvasDefaultProps.borderWidth,\n    borderColor,\n    annotations = canvasDefaultProps.annotations,\n    legendLabel,\n    tooltipLabel,\n    valueFormat,\n    isInteractive = canvasDefaultProps.isInteractive,\n    tooltip = canvasDefaultProps.tooltip as BarTooltipComponent<D>,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    legends,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n    role,\n    forwardedRef,\n    enableTotals = canvasDefaultProps.enableTotals,\n    totalsOffset = canvasDefaultProps.totalsOffset,\n}: InnerBarCanvasProps<D>) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const theme = useTheme()\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        bars,\n        barsWithValue,\n        xScale,\n        yScale,\n        getLabel,\n        getTooltipLabel,\n        getBorderColor,\n        getLabelColor,\n        shouldRenderBarLabel,\n        legendsWithData,\n        barTotals,\n        getColor,\n    } = useBar<D>({\n        indexBy,\n        label,\n        tooltipLabel,\n        valueFormat,\n        colors,\n        colorBy,\n        borderColor,\n        labelTextColor,\n        groupMode,\n        layout,\n        data,\n        keys,\n        margin,\n        width: innerWidth,\n        height: innerHeight,\n        padding,\n        innerPadding,\n        valueScale,\n        indexScale,\n        enableLabel,\n        labelSkipWidth,\n        labelSkipHeight,\n        legends,\n        legendLabel,\n        totalsOffset,\n    })\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    // Using any because return type isn't correct\n    const boundAnnotations: any = useComputedAnnotations({\n        annotations: useAnnotations({\n            data: bars,\n            annotations,\n            getPosition: node => ({\n                x: node.x,\n                y: node.y,\n            }),\n            getDimensions: ({ width, height }) => ({\n                width,\n                height,\n                size: Math.max(width, height),\n            }),\n        }),\n    })\n\n    // We use `any` here until we can figure out the best way to type xScale/yScale\n    const layerContext: BarCanvasCustomLayerProps<D> = useMemo(\n        () => ({\n            borderRadius,\n            borderWidth,\n            isInteractive,\n            isFocusable: false,\n            labelSkipWidth,\n            labelSkipHeight,\n            margin,\n            width,\n            height,\n            innerWidth,\n            innerHeight,\n            bars,\n            legendData: legendsWithData,\n            enableLabel,\n            xScale,\n            yScale,\n            tooltip,\n            getTooltipLabel,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            getColor,\n        }),\n        [\n            borderRadius,\n            borderWidth,\n            isInteractive,\n            labelSkipWidth,\n            labelSkipHeight,\n            margin,\n            width,\n            height,\n            innerWidth,\n            innerHeight,\n            bars,\n            legendsWithData,\n            enableLabel,\n            xScale,\n            yScale,\n            tooltip,\n            getTooltipLabel,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            getColor,\n        ]\n    )\n\n    const formatValue = useValueFormatter(valueFormat)\n    const computeLabelLayout = useComputeLabelLayout(\n        layout,\n        valueScale?.reverse ?? false,\n        labelPosition,\n        labelOffset\n    )\n\n    useEffect(() => {\n        if (!canvasEl.current) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')!\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (layer === 'grid') {\n                if (isNumber(theme.grid.line.strokeWidth) && theme.grid.line.strokeWidth > 0) {\n                    ctx.lineWidth = theme.grid.line.strokeWidth\n                    ctx.strokeStyle = theme.grid.line.stroke as string\n\n                    if (enableGridX) {\n                        renderGridLinesToCanvas<string | number>(ctx, {\n                            width: innerWidth,\n                            height: innerHeight,\n                            scale: xScale,\n                            axis: 'x',\n                            values: gridXValues,\n                        })\n                    }\n\n                    if (enableGridY) {\n                        renderGridLinesToCanvas<string | number>(ctx, {\n                            width: innerWidth,\n                            height: innerHeight,\n                            scale: yScale,\n                            axis: 'y',\n                            values: gridYValues,\n                        })\n                    }\n                }\n            } else if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale: xScale,\n                    yScale: yScale,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            } else if (layer === 'bars') {\n                setCanvasFont(ctx, theme.text)\n\n                barsWithValue.forEach(bar => {\n                    renderBar(ctx, {\n                        bar,\n                        borderColor: getBorderColor(bar) as string,\n                        borderRadius,\n                        borderWidth,\n                        label: getLabel(bar.data),\n                        shouldRenderLabel: shouldRenderBarLabel(bar),\n                        labelStyle: {\n                            ...theme.labels.text,\n                            fill: getLabelColor(bar) as string,\n                        },\n                        ...computeLabelLayout(bar.width, bar.height),\n                    })\n                })\n            } else if (layer === 'legends') {\n                legendsWithData.forEach(([legend, data]) => {\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            } else if (layer === 'annotations') {\n                renderAnnotationsToCanvas(ctx, { annotations: boundAnnotations, theme })\n            } else if (layer === 'totals' && enableTotals) {\n                renderTotalsToCanvas(ctx, barTotals, theme, layout)\n            } else if (typeof layer === 'function') {\n                layer(ctx, layerContext)\n            }\n        })\n\n        ctx.save()\n    }, [\n        axisBottom,\n        axisLeft,\n        axisRight,\n        axisTop,\n        barsWithValue,\n        borderRadius,\n        borderWidth,\n        boundAnnotations,\n        enableGridX,\n        enableGridY,\n        getBorderColor,\n        getLabel,\n        getLabelColor,\n        gridXValues,\n        gridYValues,\n        groupMode,\n        height,\n        innerHeight,\n        innerWidth,\n        layerContext,\n        layers,\n        layout,\n        legendsWithData,\n        margin.left,\n        margin.top,\n        outerHeight,\n        outerWidth,\n        pixelRatio,\n        renderBar,\n        xScale,\n        yScale,\n        shouldRenderBarLabel,\n        theme,\n        width,\n        barTotals,\n        enableTotals,\n        formatValue,\n        computeLabelLayout,\n    ])\n\n    const handleMouseHover = useCallback(\n        (event: React.MouseEvent<HTMLCanvasElement>) => {\n            if (!bars) return\n            if (!canvasEl.current) return\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            const bar = findBarUnderCursor(bars, margin, x, y)\n\n            if (bar !== undefined) {\n                showTooltipFromEvent(\n                    createElement(tooltip, {\n                        ...bar.data,\n                        color: bar.color,\n                        label: bar.label,\n                        value: Number(bar.data.value),\n                    }),\n                    event\n                )\n\n                if (event.type === 'mouseenter') {\n                    onMouseEnter?.(bar.data, event)\n                }\n            } else {\n                hideTooltip()\n            }\n        },\n        [hideTooltip, margin, onMouseEnter, bars, showTooltipFromEvent, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: React.MouseEvent<HTMLCanvasElement>) => {\n            if (!bars) return\n            if (!canvasEl.current) return\n\n            hideTooltip()\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            const bar = findBarUnderCursor(bars, margin, x, y)\n\n            if (bar) {\n                onMouseLeave?.(bar.data, event)\n            }\n        },\n        [hideTooltip, margin, onMouseLeave, bars]\n    )\n\n    const handleClick = useCallback(\n        (event: React.MouseEvent<HTMLCanvasElement>) => {\n            if (!bars) return\n            if (!canvasEl.current) return\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            const bar = findBarUnderCursor(bars, margin, x, y)\n\n            if (bar !== undefined) {\n                onClick?.({ ...bar.data, color: bar.color }, event)\n            }\n        },\n        [margin, onClick, bars]\n    )\n\n    return (\n        <canvas\n            ref={mergeRefs(canvasEl, forwardedRef)}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n            role={role}\n        />\n    )\n}\n\nexport const BarCanvas = forwardRef(\n    <RawDatum extends BarDatum>(\n        { isInteractive, renderWrapper, theme, ...props }: BarCanvasProps<RawDatum>,\n        ref: Ref<HTMLCanvasElement>\n    ) => (\n        <Container\n            isInteractive={isInteractive}\n            renderWrapper={renderWrapper}\n            theme={theme}\n            animate={false}\n        >\n            <InnerBarCanvas<RawDatum> {...props} isInteractive={isInteractive} forwardedRef={ref} />\n        </Container>\n    )\n) as <RawDatum extends BarDatum>(\n    props: WithChartRef<BarCanvasProps<RawDatum>, HTMLCanvasElement>\n) => ReactElement\n", "import { forwardRef, Ref, ReactElement } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport { Bar } from './Bar'\nimport { BarDatum, ResponsiveBarSvgProps } from './types'\n\nexport const ResponsiveBar = forwardRef(\n    <D extends BarDatum>(\n        {\n            defaultWidth,\n            defaultHeight,\n            onResize,\n            debounceResize,\n            ...props\n        }: Omit<ResponsiveBarSvgProps<D>, 'ref'>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultHeight}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }) => <Bar<D> {...props} width={width} height={height} ref={ref} />}\n        </ResponsiveWrapper>\n    )\n) as <D extends BarDatum>(props: ResponsiveBarSvgProps<D>) => ReactElement\n", "import { ForwardedRef, forwardRef, ReactElement } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\nimport { BarDatum, ResponsiveBarCanvasProps } from './types'\nimport { BarCanvas } from './BarCanvas'\n\nexport const ResponsiveBarCanvas = forwardRef(\n    <D extends BarDatum>(\n        {\n            defaultWidth,\n            defaultHeight,\n            onResize,\n            debounceResize,\n            ...props\n        }: Omit<ResponsiveBarCanvasProps<D>, 'ref'>,\n        ref: ForwardedRef<HTMLCanvasElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultHeight}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }) => (\n                <BarCanvas<D> {...props} width={width} height={height} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n) as <D extends BarDatum>(props: ResponsiveBarCanvasProps<D>) => ReactElement\n"],
  "mappings": "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",
  "names": ["collection", "collection", "collection", "key", "precisionCutOffs", "date", "setMilliseconds", "setSeconds", "setMinutes", "setHours", "setDate", "setMonth", "precisionCutOffsByType", "millisecond", "second", "slice", "minute", "hour", "day", "month", "year", "createPrecisionMethod", "precision", "forEach", "cutOff", "createDateNormalizer", "_ref", "_ref$format", "format", "_ref$precision", "_ref$useUTC", "useUTC", "precisionFn", "value", "Date", "parseTime", "utcParse", "timeParse", "linearScaleDefaults", "type", "min", "max", "stacked", "reverse", "clamp", "nice", "round", "createLinearScale", "data", "size", "axis", "minValue", "_data$minStacked", "maxValue", "_data$maxStacked", "_ref$min", "_ref$max", "_ref$stacked", "_ref$reverse", "_ref$clamp", "_ref$nice", "_ref$round", "minStacked", "maxStacked", "scale", "scaleLinear", "range", "interpolate", "interpolateRound", "interpolateNumber", "domain", "castLinearScale", "typedScale", "createPointScale", "_spec", "scalePoint", "all", "bandScaleDefaults", "type", "round", "createBandScale", "_ref", "data", "size", "axis", "_ref$round", "scale", "scaleBand", "range", "domain", "all", "castBandScale", "typedScale", "timeScaleDefaults", "format", "precision", "min", "max", "useUTC", "nice", "createTimeScale", "minValue", "maxValue", "_ref$format", "_ref$precision", "_ref$min", "_ref$max", "_ref$useUTC", "_ref$nice", "normalize", "createDateNormalizer", "scaleUtc", "scaleTime", "logScaleDefaults", "base", "reverse", "createLogScale", "sign", "_ref$base", "_ref$reverse", "some", "v", "Error", "hasMixedSign", "filter", "forEach", "Math", "scaleLog", "rangeRound", "symlogScaleDefaults", "constant", "createSymlogScale", "_ref$constant", "scaleSymlog", "computeScale", "spec", "data", "size", "axis", "type", "createLinearScale", "createPointScale", "createBandScale", "createTimeScale", "createLogScale", "createSymlogScale", "Error", "centerScale", "scale", "bandwidth", "offset", "round", "Math", "d", "_scale", "timeByType", "millisecond", "timeMillisecond", "utcMillisecond", "second", "timeSecond", "utcSecond", "minute", "timeMinute", "utcMinute", "hour", "timeHour", "utcHour", "day", "timeInterval", "date", "setHours", "step", "setDate", "getDate", "start", "end", "getTime", "floor", "setUTCHours", "setUTCDate", "getUTCDate", "week", "timeWeek", "utcWeek", "sunday", "timeSunday", "utcSunday", "monday", "timeMonday", "utcMonday", "tuesday", "timeTuesday", "utcTuesday", "wednesday", "timeWednesday", "utcWednesday", "thursday", "timeThursday", "utcThursday", "friday", "timeFriday", "utcFriday", "saturday", "timeSaturday", "utcSaturday", "month", "timeMonth", "utcMonth", "year", "timeYear", "utcYear", "timeTypes", "Object", "keys", "timeIntervalRegexp", "RegExp", "join", "getScaleTicks", "spec", "Array", "isArray", "matches", "match", "amount", "type", "timeType", "useUTC", "_timeType$every$range", "_timeType$every", "_scale$domain", "domain", "originalStop", "stop", "Date", "every", "Number", "range", "ticks", "interval", "Error", "value", "isFinite", "computeCartesianTicks", "_ref", "translate", "axis", "scale", "ticksPosition", "tickValues", "tickSize", "tickPadding", "tickRotation", "truncateTickAt", "_ref$engine", "engine", "values", "getScaleTicks", "textProps", "textPropsByEngine", "position", "centerScale", "line", "lineX", "lineY", "text", "textX", "textY", "isRTL", "document", "dir", "textAlign", "align", "center", "textBaseline", "baseline", "d", "_position", "x", "y", "top", "bottom", "_position2", "left", "right", "ticks", "map", "value", "processedValue", "valueLength", "String", "length", "slice", "concat", "_extends", "key", "Date", "valueOf", "getFormatter", "format", "type", "formatter", "timeFormat", "d3Format", "computeGridLines", "_ref2", "width", "height", "_values", "Array", "isArray", "lines", "_position3", "_position4", "x1", "x2", "y1", "y2", "_position5", "_position6", "memoizedAxisTick", "memo", "_format", "_value", "onClick", "textAnchor", "theme", "animatedProps", "props", "useMemo", "style", "opacity", "cursor", "event", "_jsxs", "animated", "g", "transform", "children", "_jsx", "Text", "dominantBaseline", "textTransform", "defaultAxisProps", "legendPosition", "legendOffset", "NonMemoizedAxis", "_ref$x", "_ref$y", "_ref$tickSize", "_ref$tickPadding", "_ref$tickRotation", "_ref$renderTick", "renderTick", "AxisTick", "legend", "_ref$legendPosition", "_ref$legendOffset", "ariaHidden", "useTheme", "axisTheme", "useExtendedAxisTheme", "formatValue", "_computeCartesianTick", "legendNode", "legendX", "legendY", "legendRotation", "_Fragment", "_useMotionConfig", "useMotionConfig", "animate", "springConfig", "config", "useSpring", "lineX2", "lineY2", "immediate", "getAnimatedProps", "useCallback", "tick", "getFromAnimatedProps", "transition", "useTransition", "keys", "initial", "from", "enter", "update", "leave", "transitionProps", "_state", "tickIndex", "createElement", "rotate", "domain", "Axis", "positions", "Axes", "xScale", "yScale", "axes", "isXAxis", "GridLine", "grid", "GridLines", "_createElement", "Grid", "xValues", "yValues", "xLines", "yLines", "renderAxisToCanvas", "ctx", "_axisTheme$domain$lin", "_axisTheme$ticks$line", "save", "extendAxisTheme", "setCanvasFont", "domainLineWidth", "strokeWidth", "lineWidth", "lineCap", "stroke", "strokeStyle", "beginPath", "moveTo", "lineTo", "tickLineWidth", "shouldRenderTickLine", "forEach", "degreesToRadians", "drawCanvasText", "fillText", "restore", "fill", "fillStyle", "renderAxesToCanvas", "renderGridLinesToCanvas", "_ref3", "defaultProps", "dotSize", "noteWidth", "noteTextOffset", "animate", "isSvgNote", "note", "noteType", "isValidElement", "isCanvasNote", "isCircleAnnotation", "annotationSpec", "type", "isDotAnnotation", "isRectAnnotation", "bindAnnotations", "_ref", "data", "annotations", "getPosition", "getDimensions", "reduce", "acc", "annotation", "offset", "concat", "filter", "match", "map", "datum", "position", "dimensions", "size", "width", "height", "_extends", "omit", "getLinkAngle", "sourceX", "sourceY", "targetX", "targetY", "angle", "Math", "atan2", "normalizeAngleDegrees", "radiansToDegrees", "computeAnnotation", "computedNoteX", "computedNoteY", "x", "y", "noteX", "noteY", "_annotation$noteWidth", "_annotation$noteTextO", "isNumber", "abs", "Error", "computedX", "computedY", "positionFromAngle", "degreesToRadians", "eighth", "round", "textX", "noteLineX", "points", "text", "useAnnotations", "useMemo", "useComputedAnnotations", "_ref2", "computed", "useComputedAnnotation", "AnnotationNote", "theme", "useTheme", "_useMotionConfig", "useMotionConfig", "springConfig", "config", "animatedProps", "useSpring", "immediate", "createElement", "_jsxs", "_Fragment", "children", "outlineWidth", "_jsx", "animated", "style", "strokeLinejoin", "strokeWidth", "stroke", "outlineColor", "AnnotationLink", "_ref$isOutline", "isOutline", "path", "firstPoint", "slice", "animatedPath", "useAnimatedPath", "link", "strokeLinecap", "opacity", "outlineOpacity", "fill", "d", "CircleAnnotationOutline", "radius", "outline", "circle", "cx", "cy", "r", "DotAnnotationOutline", "_ref$size", "symbol", "RectAnnotationOutline", "_ref$borderRadius", "borderRadius", "rect", "rx", "ry", "Annotation", "drawPoints", "ctx", "forEach", "index", "moveTo", "lineTo", "renderAnnotationsToCanvas", "length", "save", "lineCap", "strokeStyle", "lineWidth", "beginPath", "arc", "PI", "fillStyle", "font", "fontSize", "fontFamily", "textAlign", "textBaseline", "lineJoin", "strokeText", "fillText", "restore", "roundedRect", "ctx", "x", "y", "width", "height", "radius", "moveTo", "lineTo", "quadraticCurveTo", "closePath", "rect", "Z", "BarAnnotations", "_ref", "bars", "annotations", "boundAnnotations", "useAnnotations", "data", "getPosition", "bar", "x", "width", "y", "height", "getDimensions", "_ref2", "size", "Math", "max", "_jsx", "_Fragment", "children", "map", "annotation", "i", "Annotation", "_extends", "BarLegends", "legends", "toggleSerie", "_legend$data", "legend", "BoxLegendSvg", "containerWidth", "containerHeight", "dataFrom", "undefined", "BarItem", "_data$fill", "_ref$bar", "_objectWithoutPropertiesLoose", "_excluded", "_ref$style", "style", "borderColor", "color", "labelColor", "labelOpacity", "labelX", "labelY", "transform", "textAnchor", "borderRadius", "borderWidth", "label", "shouldRenderLabel", "isInteractive", "onClick", "onMouseEnter", "onMouseLeave", "tooltip", "isFocusable", "ariaLabel", "ariaLabelledBy", "ariaDescribedBy", "ariaDisabled", "ariaHidden", "theme", "useTheme", "_useTooltip", "useTooltip", "showTooltipFromEvent", "showTooltipAt", "hideTooltip", "renderTooltip", "useMemo", "createElement", "handleClick", "useCallback", "event", "handleTooltip", "handleMouseEnter", "handleMouseLeave", "handleFocus", "absX", "absY", "handleBlur", "_jsxs", "animated", "g", "rect", "to", "value", "rx", "ry", "fill", "strokeWidth", "stroke", "focusable", "tabIndex", "onMouseMove", "onFocus", "onBlur", "id", "index", "Text", "dominantBaseline", "fillOpacity", "labels", "text", "pointerEvents", "BarTooltip", "BasicTooltip", "formattedValue", "enableChip", "commonDefaultProps", "indexBy", "keys", "groupMode", "layout", "valueScale", "type", "nice", "round", "indexScale", "padding", "innerPadding", "enableGridX", "enableGridY", "enableLabel", "labelPosition", "labelOffset", "labelSkipWidth", "labelSkipHeight", "labelTextColor", "colorBy", "colors", "scheme", "from", "tooltipLabel", "datum", "indexValue", "initialHiddenIds", "enableTotals", "totalsOffset", "svgDefaultProps", "layers", "axisTop", "axisRight", "axisBottom", "axisLeft", "barComponent", "defs", "markers", "animate", "animateOnMount", "motionConfig", "role", "canvasDefaultProps", "renderBar", "ctx", "labelStyle", "fillStyle", "strokeStyle", "lineWidth", "beginPath", "roundedRect", "min", "textBaseline", "textAlign", "drawCanvasText", "pixelRatio", "window", "_window$devicePixelRa", "devicePixelRatio", "getIndexScale", "getIndex", "axis", "computeScale", "all", "normalizeData", "item", "reduce", "acc", "key", "filterNullValues", "Object", "coerceValue", "Number", "useComputeLabelLayout", "reverse", "computedLabelOffset", "gt", "other", "lt", "range", "start", "end", "Array", "repeat", "_", "clampToZero", "generateVerticalGroupedBars", "barWidth", "yRef", "formatValue", "getColor", "getTooltipLabel", "_ref$innerPadding", "xScale", "yScale", "margin", "compare", "cleanedData", "forEach", "domain", "length", "_xScale", "d", "_yScale", "_coerceValue", "rawValue", "barHeight", "_yScale2", "barData", "hidden", "push", "left", "top", "generateHorizontalGroupedBars", "xRef", "_ref2$innerPadding", "_yScale3", "_xScale2", "_coerceValue2", "_xScale3", "generateGroupedBars", "_ref3", "_valueScale$reverse", "_scale", "_ref3$padding", "_ref3$innerPadding", "indexScaleConfig", "_ref3$hiddenIds", "hiddenIds", "props", "filter", "includes", "_ref4", "otherAxis", "clampMin", "values", "entry", "concat", "k", "Boolean", "apply", "isFinite", "scale", "_ref5", "bandwidth", "params", "flattenDeep", "arr", "some", "isArray", "generateVerticalStackedBars", "stackedData", "stackedDataItem", "_getY", "generateHorizontalStackedBars", "_getX", "generateStackedBars", "array", "_ref4$padding", "_ref4$hiddenIds", "stack", "offset", "stackOffsetDiverging", "num", "_ref6", "getLegendData", "direction", "legendLabel", "getLegendLabel", "getPropertyAccessor", "uniqBy", "_bar$data$indexValue", "_bar$color2", "_bar$color", "updateTotalsByIndex", "totalsByIndex", "currentIndexValue", "get", "set", "updateTotalsPositivesByIndex", "totalsPositivesByIndex", "updateGreatestValueByIndex", "greatestValueByIndex", "currentGreatestValue", "updateNumberOfBarsByIndex", "numberOfBarsByIndex", "currentNumberOfBars", "useBar", "_ref$indexBy", "_ref$keys", "_ref$label", "_ref$tooltipLabel", "valueFormat", "_ref$colors", "_ref$colorBy", "_ref$borderColor", "_ref$labelTextColor", "_ref$groupMode", "_ref$layout", "_ref$padding", "_ref$valueScale", "_ref$indexScale", "_ref$initialHiddenIds", "_ref$enableLabel", "_ref$labelSkipWidth", "_ref$labelSkipHeight", "_ref$legends", "_ref$totalsOffset", "_useState", "useState", "setHiddenIds", "state", "indexOf", "usePropertyAccessor", "getLabel", "useValueFormatter", "useOrdinalColorScale", "getBorderColor", "useInheritedColor", "getLabelColor", "_generateBars", "barsWithValue", "shouldRenderBarLabel", "legendData", "find", "legendsWithData", "barTotals", "totals", "Map", "_bar$data", "totalsPositive", "xPosition", "yPosition", "animationOffset", "indexTotal", "_bar$data2", "greatestValue", "numberOfBars", "BarTotals", "springConfig", "useTransition", "barTotal", "enter", "update", "leave", "config", "immediate", "initial", "fontWeight", "fontSize", "fontFamily", "alignmentBaseline", "InnerBar", "partialMargin", "_ref$axisBottom", "_ref$axisLeft", "_ref$enableGridX", "_ref$enableGridY", "gridXValues", "gridYValues", "_ref$layers", "_ref$barComponent", "_ref$labelPosition", "_ref$labelOffset", "_ref$markers", "_ref$defs", "_ref$fill", "_ref$borderRadius", "_ref$borderWidth", "_ref$annotations", "_ref$isInteractive", "_ref$tooltip", "_ref$role", "_ref$isFocusable", "barAriaLabel", "barAriaLabelledBy", "barAriaDescribedBy", "barAriaHidden", "barAriaDisabled", "_ref$enableTotals", "forwardedRef", "_useMotionConfig", "useMotionConfig", "_useDimensions", "useDimensions", "outerWidth", "outerHeight", "innerWidth", "innerHeight", "_useBar", "computeLabelLayout", "transition", "commonProps", "boundDefs", "bindDefs", "dataKey", "targetKey", "layerById", "axes", "grid", "Axes", "right", "bottom", "Fragment", "Grid", "xValues", "yValues", "CartesianMarkers", "layerContext", "SvgWrapper", "ref", "layer", "_layerById$layer", "Bar", "forwardRef", "_ref2$isInteractive", "_ref2$animate", "_ref2$motionConfig", "renderWrapper", "Container", "findBarUnderCursor", "nodes", "node", "isCursorInRect", "InnerBarCanvas", "_ref$renderBar", "_ref$pixelRatio", "canvasEl", "useRef", "useComputedAnnotations", "useEffect", "current", "getContext", "background", "fillRect", "translate", "line", "renderGridLinesToCanvas", "renderAxesToCanvas", "setCanvasFont", "renderLegendToCanvas", "renderAnnotationsToCanvas", "save", "handleMouseHover", "_getRelativeCursor", "getRelativeCursor", "_getRelativeCursor2", "_getRelativeCursor3", "mergeRefs", "cursor", "BarCanvas", "ResponsiveBar", "defaultWidth", "defaultHeight", "onResize", "debounceResize", "ResponsiveWrapper", "Ye", "ResponsiveBarCanvas"]
}
